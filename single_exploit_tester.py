#!/usr/bin/env python3
"""
ТЕСТЕР ОДНОГО ЭКСПЛОЙТА
Тестирование конкретного эксплойта против всех целей
"""

import asyncio
import logging
import time
import os
from pathlib import Path
from dotenv import load_dotenv
from typing import Dict, List, Any

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient

# Загрузка настроек
load_dotenv()

# Импорт наших модулей
from target_config import get_all_targets, TargetPair
from src.exploits import AccountExploit, TokenExploit, ProgramExploit

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SingleExploitTester:
    """Тестер одного эксплойта против всех целей"""
    
    def __init__(self, rpc_url: str, private_key: str):
        self.client = AsyncClient(rpc_url)
        
        # Создаем keypair из приватного ключа
        private_key_bytes = bytes.fromhex(private_key)
        self.attacker_keypair = Keypair.from_bytes(private_key_bytes)
        
        # Получаем все цели
        self.targets = get_all_targets()
        
        logger.info(f"[+] Инициализирован тестер")
        logger.info(f"    Атакующий: {self.attacker_keypair.pubkey()}")
        logger.info(f"    Целей: {len(self.targets)}")
    
    async def check_balance(self) -> float:
        """Проверка баланса атакующего"""
        try:
            response = await self.client.get_balance(self.attacker_keypair.pubkey())
            balance_lamports = response.value
            balance_sol = balance_lamports / 1_000_000_000
            
            logger.info(f"[+] Баланс атакующего: {balance_sol:.9f} SOL")
            return balance_sol
            
        except Exception as e:
            logger.error(f"[-] Ошибка проверки баланса: {e}")
            return 0.0
    
    async def analyze_target(self, target: TargetPair) -> Dict[str, Any]:
        """Анализ одной цели"""
        logger.info(f"[*] Анализ цели: {target.description}")
        logger.info(f"    Keypair: {target.keypair_address}")
        logger.info(f"    Token: {target.token_address}")
        
        analysis = {
            "target": target.description,
            "keypair_address": target.keypair_address,
            "token_address": target.token_address,
            "keypair_info": None,
            "token_info": None,
            "vulnerabilities": []
        }
        
        try:
            # Анализ keypair аккаунта
            keypair_pubkey = PublicKey.from_string(target.keypair_address)
            keypair_info = await self.client.get_account_info(keypair_pubkey)
            
            if keypair_info.value:
                analysis["keypair_info"] = {
                    "lamports": keypair_info.value.lamports,
                    "owner": str(keypair_info.value.owner),
                    "data_size": len(keypair_info.value.data) if keypair_info.value.data else 0,
                    "executable": keypair_info.value.executable
                }
                logger.info(f"    Keypair баланс: {keypair_info.value.lamports / 1_000_000_000:.9f} SOL")
            else:
                logger.info(f"    Keypair аккаунт не найден")
            
            # Анализ token аккаунта
            token_pubkey = PublicKey.from_string(target.token_address)
            token_info = await self.client.get_account_info(token_pubkey)
            
            if token_info.value:
                analysis["token_info"] = {
                    "lamports": token_info.value.lamports,
                    "owner": str(token_info.value.owner),
                    "data_size": len(token_info.value.data) if token_info.value.data else 0,
                    "executable": token_info.value.executable
                }
                logger.info(f"    Token данные: {len(token_info.value.data) if token_info.value.data else 0} байт")
            else:
                logger.info(f"    Token аккаунт не найден")
            
        except Exception as e:
            logger.error(f"[-] Ошибка анализа цели {target.description}: {e}")
            analysis["error"] = str(e)
        
        return analysis
    
    async def test_account_exploit(self, target: TargetPair) -> Dict[str, Any]:
        """Тест Account эксплойта"""
        logger.info(f"[*] Тест Account эксплойта на {target.description}")
        
        try:
            # Создаем эксплойт
            exploit = AccountExploit(self.attacker_keypair)
            
            # Настраиваем цель
            target_pubkey = PublicKey.from_string(target.keypair_address)
            
            # Выполняем тест (безопасный режим)
            result = {
                "exploit_type": "account_exploit",
                "target": target.description,
                "success": False,
                "details": "Тест в безопасном режиме"
            }
            
            logger.info(f"[+] Account эксплойт протестирован на {target.description}")
            return result
            
        except Exception as e:
            logger.error(f"[-] Ошибка Account эксплойта на {target.description}: {e}")
            return {
                "exploit_type": "account_exploit",
                "target": target.description,
                "success": False,
                "error": str(e)
            }
    
    async def test_token_exploit(self, target: TargetPair) -> Dict[str, Any]:
        """Тест Token эксплойта"""
        logger.info(f"[*] Тест Token эксплойта на {target.description}")
        
        try:
            # Создаем эксплойт
            exploit = TokenExploit(self.attacker_keypair)
            
            # Настраиваем цель
            target_pubkey = PublicKey.from_string(target.token_address)
            
            # Выполняем тест (безопасный режим)
            result = {
                "exploit_type": "token_exploit",
                "target": target.description,
                "success": False,
                "details": "Тест в безопасном режиме"
            }
            
            logger.info(f"[+] Token эксплойт протестирован на {target.description}")
            return result
            
        except Exception as e:
            logger.error(f"[-] Ошибка Token эксплойта на {target.description}: {e}")
            return {
                "exploit_type": "token_exploit",
                "target": target.description,
                "success": False,
                "error": str(e)
            }
    
    async def run_single_exploit_test(self, exploit_type: str) -> Dict[str, Any]:
        """Запуск одного типа эксплойта против всех целей"""
        logger.info("=" * 80)
        logger.info(f"[!] ТЕСТИРОВАНИЕ {exploit_type.upper()} ЭКСПЛОЙТА")
        logger.info("=" * 80)
        
        # Проверка баланса
        balance = await self.check_balance()
        if balance < 0.001:
            logger.warning(f"[!] Низкий баланс: {balance:.9f} SOL")
        
        results = {
            "exploit_type": exploit_type,
            "attacker": str(self.attacker_keypair.pubkey()),
            "balance": balance,
            "targets_tested": len(self.targets),
            "target_results": [],
            "summary": {}
        }
        
        # Тестируем каждую цель
        for i, target in enumerate(self.targets, 1):
            logger.info(f"\n[{i}/{len(self.targets)}] Тестирование {target.description}")
            
            # Анализ цели
            analysis = await self.analyze_target(target)
            
            # Выбор эксплойта
            if exploit_type == "account":
                exploit_result = await self.test_account_exploit(target)
            elif exploit_type == "token":
                exploit_result = await self.test_token_exploit(target)
            else:
                exploit_result = {"error": f"Неизвестный тип эксплойта: {exploit_type}"}
            
            # Объединяем результаты
            target_result = {
                "index": i,
                "analysis": analysis,
                "exploit_result": exploit_result
            }
            
            results["target_results"].append(target_result)
        
        # Статистика
        successful_tests = sum(1 for r in results["target_results"] 
                             if r["exploit_result"].get("success", False))
        
        results["summary"] = {
            "total_targets": len(self.targets),
            "successful_exploits": successful_tests,
            "success_rate": (successful_tests / len(self.targets) * 100) if self.targets else 0
        }
        
        logger.info("=" * 80)
        logger.info(f"[=] РЕЗУЛЬТАТЫ {exploit_type.upper()} ЭКСПЛОЙТА")
        logger.info(f"[+] Протестировано целей: {len(self.targets)}")
        logger.info(f"[+] Успешных эксплойтов: {successful_tests}")
        logger.info(f"[%] Процент успеха: {results['summary']['success_rate']:.1f}%")
        logger.info("=" * 80)
        
        return results
    
    async def close(self):
        """Закрытие соединений"""
        await self.client.close()

async def main():
    """Главная функция"""
    print("[!] SINGLE EXPLOIT TESTER")
    print("Тестирование одного эксплойта против всех целей")
    print()
    
    # Загрузка настроек
    rpc_url = os.getenv('SOLANA_RPC_URL', 'https://api.mainnet.solana.com')
    private_key = os.getenv('SOLANA_PRIVKEY', '')
    
    if not private_key:
        print("[-] SOLANA_PRIVKEY не найден!")
        return
    
    # Выбор типа эксплойта
    exploit_type = input("Выберите тип эксплойта (account/token): ").strip().lower()
    if exploit_type not in ['account', 'token']:
        print("[-] Неверный тип эксплойта!")
        return
    
    # Инициализация тестера
    tester = SingleExploitTester(rpc_url, private_key)
    
    try:
        # Запуск тестов
        results = await tester.run_single_exploit_test(exploit_type)
        
        # Сохранение результатов
        import json
        report_path = f"single_exploit_{exploit_type}_report.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False, default=str)
        
        print(f"\n[+] Отчет сохранен: {report_path}")
        
    except Exception as e:
        logger.error(f"[-] Критическая ошибка: {e}")
        raise
    
    finally:
        await tester.close()

if __name__ == "__main__":
    asyncio.run(main())
