"""
Единый скрипт для создания и развертывания уязвимых активов в Solana.

Этот скрипт предназначен для создания полного набора уязвимых токенов, 
аккаунтов и программ, необходимых для тестирования всех модулей эксплойтов.

ВНИМАНИЕ: Скрипт работает с mainnet. Используйте с осторожностью.
"""

import asyncio
import os
import logging
from typing import List, Optional
from importlib.metadata import version

from dotenv import load_dotenv
from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solders.system_program import create_account, CreateAccountParams
from solders.transaction import Transaction
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Confirmed
from solana.rpc.types import TxOpts
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import initialize_mint, InitializeMintParams, initialize_account, InitializeAccountParams

# --- Настройка логирования ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Загрузка переменных окружения ---
load_dotenv()

class VulnerableAssetFactory:
    """Фабрика для создания уязвимых активов на Solana."""

    def __init__(self):
        """Инициализация фабрики с использованием данных из .env."""
        self.rpc_endpoints = self._load_rpc_endpoints()
        privkey_str = os.getenv("SOLANA_PRIVKEY")
        
        if not self.rpc_endpoints or not privkey_str:
            raise ValueError("SOLANA_RPC_URL и SOLANA_PRIVKEY должны быть установлены в .env")

        self.client: Optional[AsyncClient] = None
        self.payer = Keypair.from_bytes(bytes.fromhex(privkey_str))
        logging.info(f"Фабрика инициализирована. Payer: {self.payer.pubkey()}")

    def _load_rpc_endpoints(self) -> List[str]:
        """Загружает все RPC эндпоинты из .env."""
        endpoints = []
        main_rpc = os.getenv("SOLANA_RPC_URL")
        if main_rpc: 
            endpoints.append(main_rpc)
        
        i = 1
        while True:
            fallback = os.getenv(f"SOLANA_RPC_FALLBACK_{i}")
            if fallback:
                endpoints.append(fallback)
                i += 1
            else:
                break
        logging.info(f"Загружено {len(endpoints)} RPC эндпоинтов.")
        return endpoints

    async def connect(self):
        """Проверка и установка подключения к наиболее стабильному RPC."""
        for rpc_url in self.rpc_endpoints:
            try:
                logging.info(f"Попытка подключения к {rpc_url}...")
                client = AsyncClient(rpc_url)
                await client.is_connected() # Простая проверка жизнеспособности
                balance = await client.get_balance(self.payer.pubkey())
                self.client = client
                logging.info(f"✅ Успешное подключение к {rpc_url}")
                logging.info(f"Баланс плательщика: {balance.value / 1e9:.6f} SOL")
                if balance.value == 0:
                    logging.warning("Баланс плательщика равен нулю. Транзакции невозможны.")
                return
            except Exception as e:
                logging.warning(f"Не удалось подключиться к {rpc_url}: {e}")
                if 'client' in locals() and client:
                    await client.close()
        
        raise ConnectionError("Не удалось подключиться ни к одному из RPC эндпоинтов.")

    async def close(self):
        """Закрытие RPC клиента."""
        if self.client:
            await self.client.close()
            logging.info("Соединение с RPC закрыто.")

    # --- Раздел 1: Создание уязвимых аккаунтов ---

    async def create_uninitialized_account(self, lamports: int = 1_000_000) -> Optional[PublicKey]:
        """
        Создает аккаунт, пополняет его, но не присваивает программу-владельца.
        Владельцем остается System Program.
        """
        if not self.client:
            raise ConnectionError("Клиент RPC не инициализирован.")
            
        logging.info(f"Создание неинициализированного аккаунта с {lamports / 1e9:.6f} SOL...")
        new_account = Keypair()
        
        try:
            ix = create_account(
                CreateAccountParams(
                    from_pubkey=self.payer.pubkey(),
                    to_pubkey=new_account.pubkey(),
                    lamports=lamports,
                    space=0,
                    owner=PublicKey.from_string("11111111111111111111111111111111") # System Program
                )
            )
            
            latest_blockhash = await self.client.get_latest_blockhash()
            tx = Transaction.new_signed_with_payer(
                [ix],
                self.payer.pubkey(),
                [self.payer, new_account],
                latest_blockhash.value.blockhash,
            )
            
            opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
            signature = await self.client.send_raw_transaction(bytes(tx), opts=opts)
            await self.client.confirm_transaction(signature.value, Confirmed, sleep_secs=5, timeout=120)
            
            logging.info(f"✅ Успешно создан неинициализированный аккаунт: {new_account.pubkey()}")
            logging.info(f"   Транзакция: {signature.value}")
            return new_account.pubkey()
        except Exception as e:
            logging.error(f"Ошибка при создании неинициализированного аккаунта: {e}")
            return None

    async def create_account_with_wrong_owner(
        self, 
        owner_pubkey: PublicKey, 
        space: int, 
        lamports: Optional[int] = None
    ) -> Optional[PublicKey]:
        """
        Создает аккаунт с указанным владельцем и размером данных.
        Уязвимость возникает, если клиент ожидает другого владельца.
        """
        if not self.client:
            raise ConnectionError("Клиент RPC не инициализирован.")

        if lamports is None:
            lamports_res = await self.client.get_minimum_balance_for_rent_exemption(space)
            lamports = lamports_res.value
        
        logging.info(
            f"Создание аккаунта (владелец: {owner_pubkey}, "
            f"размер: {space} байт, баланс: {lamports / 1e9:.9f} SOL)..."
        )
        new_account = Keypair()
        
        try:
            ix = create_account(
                CreateAccountParams(
                    from_pubkey=self.payer.pubkey(),
                    to_pubkey=new_account.pubkey(),
                    lamports=lamports,
                    space=space,
                    owner=owner_pubkey
                )
            )
            
            latest_blockhash = await self.client.get_latest_blockhash()
            tx = Transaction.new_signed_with_payer(
                [ix],
                self.payer.pubkey(),
                [self.payer, new_account],
                latest_blockhash.value.blockhash,
            )
            
            opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
            signature = await self.client.send_raw_transaction(bytes(tx), opts=opts)
            await self.client.confirm_transaction(signature.value, Confirmed, sleep_secs=5, timeout=120)
            
            logging.info(f"✅ Успешно создан аккаунт с кастомным владельцем: {new_account.pubkey()}")
            logging.info(f"   Транзакция: {signature.value}")
            return new_account.pubkey()
        except Exception as e:
            logging.error(f"Ошибка при создании аккаунта с кастомным владельцем: {e}")
            return None

    # --- Раздел 2: Создание уязвимых SPL-токенов ---

    async def create_token_with_mint_authority(
        self, 
        decimals: int
    ) -> Optional[PublicKey]:
        """
        Создает новый SPL-токен, но оставляет права на минтинг у создателя (payer).
        Это позволяет создателю в любой момент выпустить новые токены.
        """
        if not self.client:
            raise ConnectionError("Клиент RPC не инициализирован.")

        mint_keypair = Keypair()
        logging.info(f"Создание токена с сохраненными правами на минтинг (decimals: {decimals})...")
        logging.info(f"Новый адрес токена (Mint Address): {mint_keypair.pubkey()}")

        try:
            lamports_res = await self.client.get_minimum_balance_for_rent_exemption(82)
            lamports = lamports_res.value

            create_account_ix = create_account(
                CreateAccountParams(
                    from_pubkey=self.payer.pubkey(),
                    to_pubkey=mint_keypair.pubkey(),
                    lamports=lamports,
                    space=82,
                    owner=TOKEN_PROGRAM_ID,
                )
            )

            initialize_mint_ix = initialize_mint(
                InitializeMintParams(
                    program_id=TOKEN_PROGRAM_ID,
                    mint=mint_keypair.pubkey(),
                    decimals=decimals,
                    mint_authority=self.payer.pubkey(),
                    freeze_authority=None
                )
            )

            latest_blockhash = await self.client.get_latest_blockhash()
            tx = Transaction.new_signed_with_payer(
                [create_account_ix, initialize_mint_ix],
                self.payer.pubkey(),
                [self.payer, mint_keypair],
                latest_blockhash.value.blockhash,
            )

            opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
            signature = await self.client.send_raw_transaction(bytes(tx), opts=opts)
            await self.client.confirm_transaction(signature.value, Confirmed, sleep_secs=5, timeout=120)
            
            logging.info(f"✅ Успешно создан уязвимый токен: {mint_keypair.pubkey()}")
            logging.info(f"   Транзакция: {signature.value}")
            return mint_keypair.pubkey()
        except Exception as e:
            logging.error(f"Ошибка при создании уязвимого токена: {e}")
            return None

    async def create_vulnerable_token_account(
        self, 
        mint_pubkey: PublicKey
    ) -> Optional[PublicKey]:
        """
        Создает токен-аккаунт, но устанавливает владельцем payer'а.
        """
        if not self.client:
            raise ConnectionError("Клиент RPC не инициализирован.")

        token_account_keypair = Keypair()

        logging.info(f"Создание уязвимого токен-аккаунта для токена {mint_pubkey}...")
        logging.info(f"Реальный владелец (атакер): {self.payer.pubkey()}")
        logging.info(f"Адрес токен-аккаунта: {token_account_keypair.pubkey()}")

        try:
            space = 165
            lamports_res = await self.client.get_minimum_balance_for_rent_exemption(space)
            create_account_ix = create_account(
                CreateAccountParams(
                    from_pubkey=self.payer.pubkey(),
                    to_pubkey=token_account_keypair.pubkey(),
                    lamports=lamports_res.value,
                    space=space,
                    owner=TOKEN_PROGRAM_ID,
                )
            )

            initialize_account_ix = initialize_account(
                InitializeAccountParams(
                    program_id=TOKEN_PROGRAM_ID,
                    account=token_account_keypair.pubkey(),
                    mint=mint_pubkey,
                    owner=self.payer.pubkey()
                )
            )

            latest_blockhash = await self.client.get_latest_blockhash()
            tx = Transaction.new_signed_with_payer(
                [create_account_ix, initialize_account_ix],
                self.payer.pubkey(),
                [self.payer, token_account_keypair],
                latest_blockhash.value.blockhash,
            )

            opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
            signature = await self.client.send_raw_transaction(bytes(tx), opts=opts)
            await self.client.confirm_transaction(signature.value, Confirmed, sleep_secs=5, timeout=120)
            
            logging.info(f"✅ Успешно создан уязвимый токен-аккаунт: {token_account_keypair.pubkey()}")
            logging.info(f"   Транзакция: {signature.value}")
            return token_account_keypair.pubkey()
        except Exception as e:
            logging.error(f"Ошибка при создании уязвимого токен-аккаунта: {e}")
            return None

    except Exception as e:
        logging.error(f"Ошибка при создании аккаунта с кастомным владельцем: {e}")
        return None

async def create_uninitialized_account(self, lamports: int = 1_000_000) -> Optional[PublicKey]:
    """
    Создает аккаунт, пополняет его, но не присваивает программу-владельца.
    Владельцем остается System Program.
    """
    logging.info(f"Создание неинициализированного аккаунта с {lamports / 1e9:.6f} SOL...")
    new_account = Keypair()
    
    try:
        # Просто создаем аккаунт и переводим на него немного SOL
        # Мы не используем Assign, поэтому владелец - System Program
        if not self.client:
            raise ConnectionError("Клиент RPC не инициализирован. Вызовите connect() сначала.")

        ix = create_account(
            CreateAccountParams(
                from_pubkey=self.payer.pubkey(),
                to_pubkey=new_account.pubkey(),
                lamports=lamports,
                space=0, # Нет данных
                owner=PublicKey.from_string("11111111111111111111111111111111") # System Program
            )
        )
        
        latest_blockhash = await self.client.get_latest_blockhash()
        tx = Transaction.new_signed_with_payer(
            [ix], # Инструкции
            self.payer.pubkey(), # Плательщик
            [self.payer, new_account], # Все подписанты (плательщик и новый аккаунт)
            latest_blockhash.value.blockhash,
        )
        
        # Сериализуем транзакцию и отправляем как "сырые" данные
        opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
        signature = await self.client.send_raw_transaction(bytes(tx), opts=opts)
        await self.client.confirm_transaction(signature.value, Confirmed, sleep_secs=5, timeout=120)
        
        logging.info(f"✅ Успешно создан неинициализированный аккаунт: {new_account.pubkey()}")
        logging.info(f"   Транзакция: {signature.value}")
        return new_account.pubkey()
    except Exception as e:
        logging.error(f"Ошибка при создании неинициализированного аккаунта: {e}")
        return None

async def main():
    """Главная функция для демонстрации создания уязвимых активов."""
    factory = VulnerableAssetFactory()
    await factory.connect()

    try:
        # --- Демонстрация создания уязвимых аккаунтов ---
        logging.info("\n--- Начинаем создание уязвимых аккаунтов ---")
        
        # 1. Неинициализированный аккаунт
        uninitialized_pubkey = await factory.create_uninitialized_account()
        if uninitialized_pubkey:
            logging.info(f"Адрес созданного неинициализированного аккаунта: {uninitialized_pubkey}")

        # 2. Аккаунт с неправильным владельцем
        logging.info("\n--- Создание аккаунта с неправильным владельцем ---")
        # Используем программу Memo как "неправильного" владельца
        memo_program_id = PublicKey.from_string("Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo")
        wrong_owner_pubkey = await factory.create_account_with_wrong_owner(
            owner_pubkey=memo_program_id,
            space=100 # Просто для примера
        )
        if wrong_owner_pubkey:
            logging.info(f"Адрес аккаунта с неправильным владельцем: {wrong_owner_pubkey}")

        # 3. Токен с сохраненными правами на минтинг
        logging.info("\n--- Создание токена с сохраненными правами на минтинг ---")
        vulnerable_token_pubkey = await factory.create_token_with_mint_authority(decimals=9)
        if vulnerable_token_pubkey:
            logging.info(f"Адрес уязвимого токена: {vulnerable_token_pubkey}")

            # 4. Уязвимый токен-аккаунт для созданного токена
            logging.info("\n--- Создание уязвимого токен-аккаунта ---")
            vulnerable_token_account_pubkey = await factory.create_vulnerable_token_account(
                mint_pubkey=vulnerable_token_pubkey
            )
            if vulnerable_token_account_pubkey:
                logging.info(f"Адрес уязвимого токен-аккаунта: {vulnerable_token_account_pubkey}")

    finally:
        await factory.close()

if __name__ == "__main__":
    asyncio.run(main())
