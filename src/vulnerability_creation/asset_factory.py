import logging
from typing import List, Optional

from solders.keypair import Keypair
from solders.instruction import Instruction
from solders.keypair import Keypair
from solders.message import Message
from solders.pubkey import Pubkey as PublicKey
from solders.system_program import create_account, CreateAccountParams
from solders.transaction import Transaction
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Confirmed
from solana.rpc.types import TxOpts
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import initialize_mint, InitializeMintParams

from .vulnerable_asset import VulnerableAsset
from solana.rpc.types import TxOpts
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import initialize_mint, InitializeMintParams, initialize_account, InitializeAccountParams

class VulnerableAssetFactory:
    """Фабрика для создания уязвимых активов на Solana."""

    def __init__(self, rpc_endpoints: List[str], attacker_keypair: Keypair):
        """Инициализация фабрики."""
        self.rpc_endpoints = rpc_endpoints
        self.attacker_keypair = attacker_keypair
        self.client = AsyncClient(self.rpc_endpoints[0])
        logging.info(f"Фабрика активов инициализирована. Payer: {self.attacker_keypair.pubkey()}")

    async def close(self):
        """Закрытие RPC клиента."""
        if self.client:
            await self.client.close()
            logging.info("Соединение с RPC закрыто.")

    async def _send_and_confirm_tx(self, instructions: List[Instruction], signers: List[Keypair]) -> Optional[str]:
        """Создает, подписывает, отправляет и подтверждает транзакцию."""
        try:
            latest_blockhash_res = await self.client.get_latest_blockhash()
            blockhash = latest_blockhash_res.value.blockhash

            message = Message.new_with_blockhash(
                instructions,
                self.attacker_keypair.pubkey(),  # Payer
                blockhash
            )
            
            tx = Transaction.new_unsigned(message)
            tx.sign([self.attacker_keypair] + signers, blockhash)

            opts = TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
            signature = await self.client.send_transaction(tx, opts=opts)
            await self.client.confirm_transaction(signature.value, Confirmed)
            logging.info(f"   Транзакция подтверждена: {signature.value}")
            return str(signature.value)
        except Exception as e:
            logging.error(f"Ошибка при отправке/подтверждении транзакции: {e}", exc_info=True)
            return None

    async def create_uninitialized_account(self, lamports: int = 1_000_000) -> Optional[VulnerableAsset]:
        logging.info(f"Создание неинициализированного аккаунта с {lamports / 1e9:.6f} SOL...")
        new_account = Keypair()
        ix = create_account(
            CreateAccountParams(
                from_pubkey=self.attacker_keypair.pubkey(),
                to_pubkey=new_account.pubkey(),
                lamports=lamports,
                space=0,
                owner=PublicKey.from_string("11111111111111111111111111111111")
            )
        )
        signature = await self._send_and_confirm_tx([ix], [new_account])
        if signature:
            logging.info(f"✅ Успешно создан неинициализированный аккаунт: {new_account.pubkey()}")
            return VulnerableAsset(
                vulnerability_type="Uninitialized Account",
                address=new_account.pubkey(),
                keypair=new_account
            )
        return None

    async def create_token_with_mint_authority(self, decimals: int) -> Optional[VulnerableAsset]:
        mint_keypair = Keypair()
        logging.info(f"Создание токена с сохраненными правами на минтинг (Mint: {mint_keypair.pubkey()})...")
        lamports_res = await self.client.get_minimum_balance_for_rent_exemption(82)
        create_account_ix = create_account(
            CreateAccountParams(
                from_pubkey=self.attacker_keypair.pubkey(),
                to_pubkey=mint_keypair.pubkey(),
                lamports=lamports_res.value,
                space=82,
                owner=TOKEN_PROGRAM_ID,
            )
        )
        initialize_mint_ix = initialize_mint(
            InitializeMintParams(
                program_id=TOKEN_PROGRAM_ID,
                mint=mint_keypair.pubkey(),
                decimals=decimals,
                mint_authority=self.attacker_keypair.pubkey(),
                freeze_authority=None
            )
        )
        instructions = [create_account_ix, initialize_mint_ix]
        signature = await self._send_and_confirm_tx(instructions, [mint_keypair])
        if signature:
            logging.info(f"✅ Успешно создан уязвимый токен: {mint_keypair.pubkey()}")
            return VulnerableAsset(
                vulnerability_type="Token with Mint Authority",
                address=mint_keypair.pubkey(),
                keypair=mint_keypair
            )
        return None

    async def create_all_vulnerable_assets(self) -> dict:
        """Создает полный набор уязвимых активов для тестирования."""
        logging.info("--- Запуск создания всех уязвимых активов ---")
        assets = {
            "uninitialized_accounts": [],
            "tokens_with_mint_authority": []
        }

        try:
            # 1. Создание неинициализированного аккаунта
            uninitialized_account = await self.create_uninitialized_account()
            if uninitialized_account:
                assets["uninitialized_accounts"].append(uninitialized_account)

            # 2. Создание токена с сохраненными правами на минтинг
            vulnerable_token = await self.create_token_with_mint_authority(decimals=9)
            if vulnerable_token:
                assets["tokens_with_mint_authority"].append(vulnerable_token)

            logging.info("--- ✅ Все уязвимые активы успешно созданы ---")
            return assets
        except Exception as e:
            logging.critical(f"Критическая ошибка при создании уязвимых активов: {e}", exc_info=True)
            return {}
