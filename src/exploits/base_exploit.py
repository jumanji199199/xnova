"""
–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö Solana —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤
"""

import asyncio
from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from datetime import datetime
import logging

from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment
from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solders.transaction import Transaction
from solders.instruction import Instruction
from solders.signature import Signature
from solders.system_program import CreateAccountParams, create_account
import os
import random

from .safety_checks import ExploitSafetyChecker

class ExploitType(Enum):
    """–¢–∏–ø—ã —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
    ACCOUNT_MANIPULATION = "account_manipulation"
    TOKEN_DRAIN = "token_drain"
    TOKEN_MANIPULATION = "token_manipulation"
    PROGRAM_UPGRADE = "program_upgrade"
    AUTHORITY_BYPASS = "authority_bypass"
    RENT_EXEMPTION = "rent_exemption"
    CROSS_PROGRAM_INVOCATION = "cross_program_invocation"
    ACCOUNT_REALLOCATION = "account_reallocation"
    SIGNATURE_VERIFICATION = "signature_verification"
    MEMORY_CORRUPTION = "memory_corruption"
    VALIDATOR_EXPLOIT = "validator_exploit"
    ARBITRARY_READ_WRITE = "arbitrary_read_write"
    RCE_VULNERABILITY = "rce_vulnerability"
    CONSENSUS_MANIPULATION = "consensus_manipulation"

class ExploitStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    PARTIAL = "partial"

@dataclass
class ExploitResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
    exploit_type: ExploitType
    status: ExploitStatus
    target_account: Optional[str] = None
    target_program: Optional[str] = None
    transaction_signatures: List[str] = field(default_factory=list)
    extracted_value: float = 0.0
    extracted_tokens: Dict[str, float] = field(default_factory=dict)
    error_message: Optional[str] = None
    execution_time: float = 0.0
    gas_used: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

class BaseExploit(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö Solana —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
    
    def __init__(self, client: AsyncClient, attacker_keypair: Keypair):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.client = client
        self.attacker_keypair = attacker_keypair
        self.attacker_pubkey = attacker_keypair.pubkey()
        
        # üö® –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–†–û–í–ï–†–û–ö –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò
        target_address = os.getenv("SOLANA_TARGET_ADDRESS")
        if not target_address:
            raise ValueError("üö® SOLANA_TARGET_ADDRESS –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")
        
        self.safety_checker = ExploitSafetyChecker(target_address)
        self.our_target_pubkey = PublicKey.from_string(target_address)
        
        # –°–æ—Å—Ç–æ—è–Ω–∏–µ —ç–∫—Å–ø–ª–æ–π—Ç–∞
        self.is_running = False
        self.results: List[ExploitResult] = []
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        self.max_sol_risk = 1.0  # –ú–∞–∫—Å–∏–º—É–º SOL –¥–ª—è —Ä–∏—Å–∫–∞
        self.max_retries = 3
        self.rpc_timeout = 30  # –¢–∞–π–º–∞—É—Ç –¥–ª—è RPC –∑–∞–ø—Ä–æ—Å–æ–≤
        self.retry_delay = 1.0
        
        self.logger.info(f"üöÄ –ë–∞–∑–æ–≤—ã–π —ç–∫—Å–ø–ª–æ–π—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏")
        self.logger.info(f"üéØ –ù–∞—à —Ü–µ–ª–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç: {target_address}")
        
    def _create_rpc_client(self, commitment: Commitment) -> AsyncClient:
        """–°–æ–∑–¥–∞–Ω–∏–µ RPC –∫–ª–∏–µ–Ω—Ç–∞ —Å fallback –ª–æ–≥–∏–∫–æ–π"""
        try:
            # –ü—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π RPC endpoint
            if self.rpc_url:
                self.logger.info(f"üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É RPC: {self.rpc_url}")
                return AsyncClient(self.rpc_url, commitment=commitment)
            
            # –ï—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –Ω–µ –∑–∞–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –∏–∑ fallback —Å–ø–∏—Å–∫–∞
            primary_rpc = self.rpc_endpoints[0]
            self.logger.info(f"üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ fallback RPC: {primary_rpc}")
            return AsyncClient(primary_rpc, commitment=commitment)
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è RPC –∫–ª–∏–µ–Ω—Ç–∞: {e}")
            return self._try_fallback_rpc(commitment)
    
    def _try_fallback_rpc(self, commitment: Commitment) -> AsyncClient:
        """–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ fallback RPC endpoints"""
        for i, rpc_url in enumerate(self.rpc_endpoints):
            try:
                self.logger.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ fallback RPC {i+1}/{len(self.rpc_endpoints)}: {rpc_url}")
                client = AsyncClient(rpc_url, commitment=commitment)
                self.current_rpc_index = i
                self.logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ RPC: {rpc_url}")
                return client
            except Exception as e:
                self.logger.warning(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ {rpc_url}: {e}")
                continue
        
        # –ï—Å–ª–∏ –≤—Å–µ fallback endpoints –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç
        raise ConnectionError("üö® –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∏ –∫ –æ–¥–Ω–æ–º—É RPC endpoint!")
    
    async def _safe_rpc_call(self, rpc_method, *args, **kwargs):
        """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ RPC –º–µ—Ç–æ–¥–∞ —Å retry –ª–æ–≥–∏–∫–æ–π"""
        for attempt in range(self.max_retries):
            try:
                return await rpc_method(*args, **kwargs)
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è RPC –æ—à–∏–±–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1}/{self.max_retries}): {e}")
                
                if attempt < self.max_retries - 1:
                    # –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π RPC endpoint
                    self.current_rpc_index = (self.current_rpc_index + 1) % len(self.rpc_endpoints)
                    next_rpc = self.rpc_endpoints[self.current_rpc_index]
                    self.logger.info(f"üîÑ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ RPC: {next_rpc}")
                    self.client = AsyncClient(next_rpc)
                    await asyncio.sleep(self.retry_delay)
                else:
                    raise e
    
    def validate_transfer_safety(self, from_pubkey: PublicKey, to_pubkey: PublicKey, amount: int) -> bool:
        """üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò –ü–ï–†–ï–í–û–î–ê"""
        return self.safety_checker.validate_transfer_direction(
            from_pubkey, to_pubkey, self.__class__.__name__, amount
        )
    
    def validate_target_safety(self, target_pubkey: PublicKey) -> bool:
        """üö® –ü–†–û–í–ï–†–ö–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò –¶–ï–õ–ï–í–û–ì–û –ê–ö–ö–ê–£–ù–¢–ê"""
        return self.safety_checker.validate_target_account(
            target_pubkey, self.__class__.__name__
        )
        
    @property
    @abstractmethod
    def exploit_type(self) -> ExploitType:
        """–¢–∏–ø —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        pass
    
    @abstractmethod
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–∏ –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏"""
        pass
    
    @abstractmethod
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        pass
    
    @abstractmethod
    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        pass
    
    async def get_account_info(self, pubkey: Union[PublicKey, str]) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ"""
        try:
            if isinstance(pubkey, str):
                # –ö–†–ò–¢–ò–ß–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º from_string() –¥–ª—è Base58 —Å—Ç—Ä–æ–∫, –∞ –Ω–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä!
                pubkey = PublicKey.from_string(pubkey)
            
            response = await self.client.get_account_info(pubkey)
            
            if response.value is None:
                return None
            
            account = response.value
            return {
                "pubkey": str(pubkey),
                "lamports": account.lamports,
                "owner": str(account.owner),
                "executable": account.executable,
                "rent_epoch": account.rent_epoch,
                "data_length": len(account.data) if account.data else 0,
                "data": account.data
            }
            
        except Exception as e:
            error_details = f"–¢–∏–ø: {type(e).__name__}, –°–æ–æ–±—â–µ–Ω–∏–µ: {str(e)}"
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ {pubkey}: {error_details}")
            self.logger.error(f"üîó –ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π RPC: {self.rpc_url or 'fallback'}")
            return None
    
    async def get_token_account_info(self, token_account: Union[PublicKey, str]) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ"""
        try:
            if isinstance(token_account, str):
                token_account = PublicKey.from_string(token_account)
            
            # üî• –î–õ–Ø –†–ï–ê–õ–¨–ù–û–ô –≠–ö–°–ü–õ–£–ê–¢–ê–¶–ò–ò: –ø–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ
            account_info = await self.client.get_account_info(token_account)
            if not account_info.value:
                self.logger.warning(f"–¢–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω: {token_account}")
                return None
                
            # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è mint
            try:
                data = account_info.value.data
                if len(data) < 32:
                    self.logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞: {len(data)} –±–∞–π—Ç")
                    return None
                    
                # Mint –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø–µ—Ä–≤—ã—Ö 32 –±–∞–π—Ç–∞—Ö
                mint_bytes = data[:32]
                mint_pubkey = PublicKey(mint_bytes)
                
                # –¢–∞–∫–∂–µ –ø–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
                balance_response = await self.client.get_token_account_balance(token_account)
                
                # üîß –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –æ—Ç–≤–µ—Ç–∞ –ø–µ—Ä–µ–¥ –æ–±—Ä–∞—â–µ–Ω–∏–µ–º –∫ .value
                if hasattr(balance_response, 'value'):
                    if balance_response.value is None:
                        return None
                else:
                    # –≠—Ç–æ –æ—à–∏–±–∫–∞ RPC (–Ω–∞–ø—Ä–∏–º–µ—Ä, InvalidParamsMessage)
                    self.logger.warning(f"RPC –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞ {token_account}: {type(balance_response).__name__}")
                    return None
                
                return {
                    "pubkey": str(token_account),
                    "mint": str(mint_pubkey),  # üî• –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û –î–õ–Ø –≠–ö–°–ü–õ–£–ê–¢–ê–¶–ò–ò!
                    "amount": balance_response.value.amount,
                    "decimals": balance_response.value.decimals,
                    "ui_amount": balance_response.value.ui_amount,
                    "ui_amount_string": balance_response.value.ui_amount_string
                }
                
            except Exception as parse_error:
                self.logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–∞: {parse_error}")
                return None
                
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–∫–µ–Ω –∞–∫–∫–∞—É–Ω—Ç–µ {token_account}: {e}")
            return None
    
    async def send_transaction(self, transaction: Transaction, 
                             max_retries: Optional[int] = None) -> Optional[Signature]:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
        max_retries = max_retries or self.max_retries
        
        for attempt in range(max_retries):
            try:
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π blockhash
                recent_blockhash = await self.client.get_latest_blockhash()
                transaction.recent_blockhash = recent_blockhash.value.blockhash
                
                # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
                transaction.sign(self.attacker_keypair)
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
                response = await self.client.send_transaction(transaction)
                
                if response.value:
                    self.logger.info(f"–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: {response.value}")
                    
                    # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
                    await self.client.confirm_transaction(response.value)
                    return response.value
                
            except Exception as e:
                self.logger.warning(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries} –Ω–µ —É–¥–∞–ª–∞—Å—å: {e}")
                
                if attempt < max_retries - 1:
                    await asyncio.sleep(self.retry_delay * (attempt + 1))
                else:
                    self.logger.error(f"–í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã: {e}")
        
        return None
    
    async def check_sol_balance(self, min_balance: float = 0.01) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ SOL"""
        try:
            response = await self.client.get_balance(self.attacker_pubkey)
            balance_sol = response.value / 1e9  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º lamports –≤ SOL
            
            if balance_sol < min_balance:
                self.logger.error(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ SOL: {balance_sol:.6f} < {min_balance}")
                return False
            
            self.logger.info(f"–ë–∞–ª–∞–Ω—Å SOL: {balance_sol:.6f}")
            return True
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å–∞: {e}")
            return False
    
    async def estimate_transaction_cost(self, transaction: Transaction) -> Optional[int]:
        """–û—Ü–µ–Ω–∫–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π blockhash
            recent_blockhash = await self.client.get_latest_blockhash()
            transaction.recent_blockhash = recent_blockhash.value.blockhash
            
            # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏–∏
            transaction.sign(self.attacker_keypair)
            
            # –°–∏–º—É–ª–∏—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            response = await self.client.simulate_transaction(transaction)
            
            if response.value and response.value.err is None:
                return response.value.units_consumed
            else:
                self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏: {response.value.err if response.value else 'Unknown'}")
                return None
                
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
            return None
    
    async def find_program_derived_address(self, seeds: List[bytes], program_id: PublicKey) -> tuple[PublicKey, int]:
        """–ü–æ–∏—Å–∫ Program Derived Address"""
        try:
            return PublicKey.find_program_address(seeds, program_id)
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ PDA: {e}")
            raise
    
    async def create_associated_token_account(self, mint: PublicKey, owner: PublicKey) -> Optional[PublicKey]:
        """–°–æ–∑–¥–∞–Ω–∏–µ Associated Token Account"""
        try:
            from spl.token.instructions import get_associated_token_address
            
            ata_address = get_associated_token_address(owner, mint)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∞–∫–∫–∞—É–Ω—Ç
            account_info = await self.get_account_info(ata_address)
            if account_info:
                return ata_address
            
            # –°–æ–∑–¥–∞–µ–º ATA
            from spl.token.instructions import create_associated_token_account
            
            instruction = create_associated_token_account(
                payer=self.attacker_pubkey,
                owner=owner,
                mint=mint
            )
            
            transaction = Transaction()
            transaction.add(instruction)
            
            signature = await self.send_transaction(transaction)
            if signature:
                self.logger.info(f"–°–æ–∑–¥–∞–Ω ATA: {ata_address}")
                return ata_address
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è ATA: {e}")
        
        return None
    
    def log_exploit_attempt(self, target: str, action: str, success: bool, details: str = ""):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ø—ã—Ç–∫–∏ —ç–∫—Å–ø–ª–æ–π—Ç–∞"""
        status = "SUCCESS" if success else "FAILED"
        self.logger.info(f"EXPLOIT {status}: {action} on {target[:8]}...{target[-8:]} - {details}")
    
    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤"""
        try:
            await self.client.close()
            self.logger.info("–°–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã")
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ: {e}")
    
    async def run_exploit_sequence(self, targets: List[Union[PublicKey, str]], **kwargs) -> List[ExploitResult]:
        """–ó–∞–ø—É—Å–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
        self.is_running = True
        results = []
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
            if not await self.check_sol_balance():
                raise Exception("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ SOL –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤")
            
            for target in targets:
                self.logger.info(f"–ù–∞—á–∏–Ω–∞–µ–º —ç–∫—Å–ø–ª–æ–π—Ç —Ü–µ–ª–∏: {target}")
                
                try:
                    # –°–∫–∞–Ω–∏—Ä—É–µ–º —Ü–µ–ª—å
                    scan_result = await self.scan_target(target)
                    if not scan_result.get("vulnerable", False):
                        self.logger.warning(f"–¶–µ–ª—å {target} –Ω–µ —É—è–∑–≤–∏–º–∞")
                        continue
                    
                    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —ç–∫—Å–ø–ª–æ–π—Ç
                    if not await self.prepare_exploit(target, **kwargs):
                        self.logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å —ç–∫—Å–ø–ª–æ–π—Ç –¥–ª—è {target}")
                        continue
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º —ç–∫—Å–ø–ª–æ–π—Ç
                    result = await self.execute_exploit(target, **kwargs)
                    results.append(result)
                    
                    self.log_exploit_attempt(
                        str(target), 
                        self.exploit_type.value,
                        result.status == ExploitStatus.SUCCESS,
                        f"–ò–∑–≤–ª–µ—á–µ–Ω–æ: {result.extracted_value} SOL"
                    )
                    
                except Exception as e:
                    self.logger.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–ª–æ–π—Ç–∞ —Ü–µ–ª–∏ {target}: {e}")
                    
                    # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å –æ—à–∏–±–∫–æ–π
                    error_result = ExploitResult(
                        exploit_type=self.exploit_type,
                        status=ExploitStatus.FAILED,
                        target_account=str(target),
                        error_message=str(e)
                    )
                    results.append(error_result)
        
        finally:
            self.is_running = False
            self.results.extend(results)
        
        return results
    
    def get_success_rate(self) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —É—Å–ø–µ—à–Ω—ã—Ö —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
        if not self.results:
            return 0.0
        
        successful = sum(1 for r in self.results if r.status == ExploitStatus.SUCCESS)
        return (successful / len(self.results)) * 100
    
    def get_total_extracted_value(self) -> Dict[str, float]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–π –∏–∑–≤–ª–µ—á–µ–Ω–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏"""
        total_sol = sum(r.extracted_value for r in self.results)
        total_tokens = {}
        
        for result in self.results:
            for token, amount in result.extracted_tokens.items():
                total_tokens[token] = total_tokens.get(token, 0) + amount
        
        return {
            "SOL": total_sol,
            "tokens": total_tokens
        }
