#!/usr/bin/env python3
"""
АВТОМАТИЧЕСКИЙ ТЕСТЕР ВСЕХ ЭКСПЛОЙТОВ
Последовательное тестирование всех эксплойтов против всех целей
"""

import asyncio
import logging
import time
import os
import json
from pathlib import Path
from dotenv import load_dotenv
from typing import Dict, List, Any

# Загрузка настроек
load_dotenv()

from single_exploit_tester import SingleExploitTester

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('auto_exploit_test.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class AutoExploitTester:
    """Автоматический тестер всех эксплойтов"""
    
    def __init__(self, rpc_url: str, private_key: str):
        self.rpc_url = rpc_url
        self.private_key = private_key
        
        # Список всех эксплойтов для тестирования
        self.exploit_types = [
            "account",
            "token",
            "program",
            "reentrancy",
            "memory",
            "validator"
        ]
        
        self.all_results = {}
        
    async def test_all_exploits(self) -> Dict[str, Any]:
        """Тестирование всех эксплойтов"""
        logger.info("=" * 80)
        logger.info("[!] АВТОМАТИЧЕСКОЕ ТЕСТИРОВАНИЕ ВСЕХ ЭКСПЛОЙТОВ")
        logger.info("=" * 80)
        
        start_time = time.time()
        
        for i, exploit_type in enumerate(self.exploit_types, 1):
            logger.info(f"\n[{i}/{len(self.exploit_types)}] Тестирование {exploit_type} эксплойтов...")
            
            # Создаем отдельный тестер для каждого типа
            tester = SingleExploitTester(self.rpc_url, self.private_key)
            
            try:
                # Запускаем тест
                if exploit_type in ["account", "token"]:
                    # Для этих типов у нас есть реализация
                    results = await tester.run_single_exploit_test(exploit_type)
                else:
                    # Для остальных создаем заглушку
                    results = await self.create_placeholder_test(exploit_type, tester)
                
                self.all_results[exploit_type] = results
                
            except Exception as e:
                logger.error(f"[-] Ошибка в тесте {exploit_type}: {e}")
                self.all_results[exploit_type] = {
                    "exploit_type": exploit_type,
                    "error": str(e),
                    "success": False
                }
            
            finally:
                await tester.close()
            
            # Пауза между тестами
            await asyncio.sleep(2)
        
        # Финальная статистика
        total_time = time.time() - start_time
        
        final_report = {
            "metadata": {
                "timestamp": time.time(),
                "total_execution_time": total_time,
                "exploit_types_tested": len(self.exploit_types),
                "rpc_url": self.rpc_url
            },
            "exploit_results": self.all_results,
            "summary": self.generate_summary()
        }
        
        return final_report
    
    async def create_placeholder_test(self, exploit_type: str, tester: SingleExploitTester) -> Dict[str, Any]:
        """Создание заглушки для неимплементированных эксплойтов"""
        logger.info(f"[*] Создание заглушки для {exploit_type} эксплойта")
        
        # Получаем базовую информацию
        balance = await tester.check_balance()
        
        # Анализируем все цели
        target_results = []
        for i, target in enumerate(tester.targets, 1):
            analysis = await tester.analyze_target(target)
            
            target_result = {
                "index": i,
                "analysis": analysis,
                "exploit_result": {
                    "exploit_type": exploit_type,
                    "target": target.description,
                    "success": False,
                    "details": f"{exploit_type} эксплойт не реализован (заглушка)",
                    "placeholder": True
                }
            }
            
            target_results.append(target_result)
        
        return {
            "exploit_type": exploit_type,
            "attacker": str(tester.attacker_keypair.pubkey()),
            "balance": balance,
            "targets_tested": len(tester.targets),
            "target_results": target_results,
            "summary": {
                "total_targets": len(tester.targets),
                "successful_exploits": 0,
                "success_rate": 0.0,
                "placeholder": True
            }
        }
    
    def generate_summary(self) -> Dict[str, Any]:
        """Генерация общей статистики"""
        total_exploits = len(self.exploit_types)
        successful_exploits = 0
        total_targets_tested = 0
        total_successful_targets = 0
        
        for exploit_type, results in self.all_results.items():
            if results.get("success", True) and not results.get("error"):
                successful_exploits += 1
            
            if "summary" in results:
                total_targets_tested += results["summary"].get("total_targets", 0)
                total_successful_targets += results["summary"].get("successful_exploits", 0)
        
        return {
            "total_exploit_types": total_exploits,
            "successful_exploit_types": successful_exploits,
            "exploit_success_rate": (successful_exploits / total_exploits * 100) if total_exploits > 0 else 0,
            "total_targets_tested": total_targets_tested,
            "total_successful_targets": total_successful_targets,
            "target_success_rate": (total_successful_targets / total_targets_tested * 100) if total_targets_tested > 0 else 0
        }

async def main():
    """Главная функция"""
    print("[!] AUTO EXPLOIT TESTER")
    print("Автоматическое тестирование всех эксплойтов против всех целей")
    print("Основано на анализе 155 изображений PDF")
    print()
    
    # Загрузка настроек
    rpc_url = os.getenv('SOLANA_RPC_URL', 'https://api.mainnet.solana.com')
    private_key = os.getenv('SOLANA_PRIVKEY', '')
    
    if not private_key:
        print("[-] SOLANA_PRIVKEY не найден!")
        return
    
    print(f"[+] RPC URL: {rpc_url}")
    print(f"[+] Будет протестировано 6 типов эксплойтов против 8 целей")
    
    # Предупреждение
    print("\n[!] ВНИМАНИЕ: Тестирование на MAINNET!")
    print("    Все операции выполняются с реальными адресами.")
    print("    Автоматический запуск через 5 секунд...")
    await asyncio.sleep(5)
    
    # Инициализация тестера
    auto_tester = AutoExploitTester(rpc_url, private_key)
    
    try:
        # Запуск всех тестов
        final_report = await auto_tester.test_all_exploits()
        
        # Сохранение отчета
        report_path = "auto_exploit_full_report.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(final_report, f, indent=2, ensure_ascii=False, default=str)
        
        # Вывод статистики
        summary = final_report["summary"]
        
        print("\n" + "=" * 80)
        print("[=] ФИНАЛЬНАЯ СТАТИСТИКА ВСЕХ ТЕСТОВ")
        print(f"[+] Типов эксплойтов протестировано: {summary['total_exploit_types']}")
        print(f"[+] Успешных типов эксплойтов: {summary['successful_exploit_types']}")
        print(f"[%] Процент успеха эксплойтов: {summary['exploit_success_rate']:.1f}%")
        print(f"[+] Всего целей протестировано: {summary['total_targets_tested']}")
        print(f"[+] Успешных атак на цели: {summary['total_successful_targets']}")
        print(f"[%] Процент успеха атак: {summary['target_success_rate']:.1f}%")
        print(f"[+] Время выполнения: {final_report['metadata']['total_execution_time']:.2f}s")
        print(f"[+] Отчет сохранен: {report_path}")
        print("=" * 80)
        
    except Exception as e:
        logger.error(f"[-] Критическая ошибка: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
